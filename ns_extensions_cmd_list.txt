'''
Show Commands reference
'''
## What you can do with this procedure
**The following show commands can be executed from the CLI**
- [show area](https://github.com/cisco-open/network-sketcher/wiki/8-1.-show-commands#show-area)
- [show area_device](https://github.com/cisco-open/network-sketcher/wiki/8-1.-show-commands#show-area_device)
- [show area_location](https://github.com/cisco-open/network-sketcher/wiki/8-1.-show-commands#show-area_location)
- [show attribute](https://github.com/cisco-open/network-sketcher/wiki/8-1.-show-commands#show-attribute)
- [show attribute_color](https://github.com/cisco-open/network-sketcher/wiki/8-1.-show-commands#show-attribute_color)
- [show device](https://github.com/cisco-open/network-sketcher/wiki/8-1.-show-commands#show-device)
- [show device_interface](https://github.com/cisco-open/network-sketcher/wiki/8-1.-show-commands#show-device_interface)
- [show device_location](https://github.com/cisco-open/network-sketcher/wiki/8-1.-show-commands#show-device_location)
- [show l1_interface](https://github.com/cisco-open/network-sketcher/wiki/8-1.-show-commands#show-l1_interface)
- [show l1_link](https://github.com/cisco-open/network-sketcher/wiki/8-1.-show-commands#show-l1_link)
- [show l2_broadcast_domain](https://github.com/cisco-open/network-sketcher/wiki/8-1.-show-commands#show-l2_broadcast_domain)
- [show l2_interface](https://github.com/cisco-open/network-sketcher/wiki/8-1.-show-commands#show-l2_interface)
- [show l3_broadcast_domain](https://github.com/cisco-open/network-sketcher/wiki/8-1.-show-commands#show-l3_broadcast_domain)
- [show l3_interface](https://github.com/cisco-open/network-sketcher/wiki/8-1.-show-commands#show-l3_interface)
- [show waypoint](https://github.com/cisco-open/network-sketcher/wiki/8-1.-show-commands#show-waypoint)
- [show waypoint_interface](https://github.com/cisco-open/network-sketcher/wiki/8-1.-show-commands#show-waypoint_interface)

## Basic syntax
 ```bash
python [file path]/network_sketcher.py [command] --master [master file path]
 ```
Add --one_msg option to display output on a single line
 ```bash
python [file path]/network_sketcher.py [command] --master [master file path] --one_msg
 ```
* The location of [command], --one_msg, and --master [master file path] can be changed as follows<br>
python [file path]/network_sketcher.py --one_msg -master [master file path] [command]<br>


## show area
Displays all area names.
 ```bash
python [file path]/network_sketcher.py show area　--master [master file path]
 ```

* ex.<br>
＃python .\network_sketcher.py show area　--master "C:\work\\[MASTER]test.xlsx"<br>
DC-TOP1<br>
DC-TOP2<br>
DC-TOP3<br>

## show area_device
Displays all device names in each area.
 ```bash
python [file path]/network_sketcher.py show area_device　--master [master file path]
 ```
* ex.<br>
＃python .\network_sketcher.py show area_device　--master "C:\work\\[MASTER]test.xlsx"<br>
['Site1', ['L2sw-x', 'L3sw-1', 'L3sw-2', 'R-1', 'R-2']]<br>


## show area_location
Displays area placement information. Relative location information. '\_AIR\_' indicates a blank area.
 ```bash
python [file path]/network_sketcher.py show area_location　--master [master file path]
 ```
* ex.<br>
＃python .\network_sketcher.py show area_location　--master "C:\work\\[MASTER]test.xlsx"<br>
['DC-TOP1', 'DC-TOP2', 'DC-TOP3']<br>
['Site1', 'Site2', '\_AIR\_']<br>


## show attribute
Displays attributes for all devices.

 ```bash
python [file path]/network_sketcher.py show attribute　--master [master file path]
 ```
* ex.<br>
＃python .\network_sketcher.py show attribute　--master "C:\work\\[MASTER]test.xlsx"<br>
['Default', 'Type', 'Serial', 'Version', 'Attribute-D', 'Attribute-E', 'Attribute-F', 'Attribute-G', 'Attribute-H']<br>
['DEVICE', 'FW', 'abcdergsh001', 'IOS 1x.x', '', '', '', '', '']<br>
['DEVICE', 'Switch', 'abcdergsh002', 'IOS 1x.x', '', '', '', '', '']<br>

## show attribute_color
Displays attributes for all devices. It also displays the color of the cell specified by the attribute.
The item following the device name displays the color of the cell for the device name with the value of [R,G,B]

 ```bash
python [file path]/network_sketcher.py show attribute_color　--master [master file path]
 ```
* ex.<br>
＃python .\network_sketcher.py show attribute_color　--master "C:\work\\[MASTER]test.xlsx"<br>
['Default', 'Type', 'Serial', 'Version', 'Attribute-D', 'Attribute-E', 'Attribute-F', 'Attribute-G', 'Attribute-H']<br>
["['DEVICE', [235, 241, 222]]", "['FW', [146, 208, 80]]", "['abcdergsh001', [255, 255, 255]]", "['IOS 1x.x', [255, 255, 255]]", "['', [255, 255, 255]]", "['', [255, 255, 255]]", "['', [255, 255, 255]]", "['', [255, 255, 255]]", "['', [255, 255, 255]]"]<br>
["['DEVICE', [235, 241, 222]]", "['Switch', [255, 255, 0]]", "['abcdergsh002', [255, 255, 255]]", "['IOS 1x.x', [255, 255, 255]]", "['', [255, 255, 255]]", "['', [255, 255, 255]]", "['', [255, 255, 255]]", "['', [255, 255, 255]]", "['', [255, 255, 255]]"]<br>


## show device
Displays all device names.
 ```bash
python [file path]/network_sketcher.py show device　--master [master file path]
 ```
* ex.<br>
＃python .\network_sketcher.py show device　--master "C:\work\\[MASTER]test.xlsx"<br>
DEVICE1<br>
DEVICE10<br>
DEVICE11<br>
DEVICE12<br>

## show device_interface
Displays all interface names for all devices.
 ```bash
python [file path]/network_sketcher.py show device_interface　--master [master file path]
 ```
* ex.<br>
＃python .\network_sketcher.py show device_interface　--master "C:\work\\[MASTER]test.xlsx"<br>
['DEVICE6', ['GigabitEthernet 0/3']]<br>
['DEVICE5', ['GigabitEthernet 0/4']]<br>
['DEVICE10', ['GigabitEthernet 0/5']]<br>

## show device_location
Displays device placement information within each area. It is relative location information.' AIR' means blank.
 ```bash
python [file path]/network_sketcher.py show device_location　--master [master file path]
 ```
* ex.<br>
＃python .\network_sketcher.py show device_location　--master "C:\work\\[MASTER]test.xlsx"<br>
['_tmp_', [['_AIR_', '_AIR_', '_AIR_', '_AIR_', '_AIR_', 'DEVICE1', 'DEVICE2', '_AIR_'], ['_AIR_', '_AIR_', '_AIR_', '_AIR_', '_AIR_', '_AIR_', '_AIR_', 'DEVICE3'], ['_AIR_', '_AIR_', 'DEVICE4', '_AIR_', '_AIR_', 'DEVICE5', 'DEVICE6', 'DEVICE7'], ['DEVICE8', 'DEVICE9', 'DEVICE10', 'DEVICE11', 'DEVICE12', '_AIR_', '_AIR_', '_AIR_']]]<br>

* explanation
Area name:_tmp_<br>
Device location:<br>
['_AIR_', '_AIR_', '_AIR_', '_AIR_', '_AIR_', 'DEVICE1', 'DEVICE2', '_AIR_']<br>
['_AIR_', '_AIR_', '_AIR_', '_AIR_', '_AIR_', '_AIR_', '_AIR_', 'DEVICE3']<br>
['_AIR_', '_AIR_', 'DEVICE4', '_AIR_', '_AIR_', 'DEVICE5', 'DEVICE6', 'DEVICE7']<br>
['DEVICE8', 'DEVICE9', 'DEVICE10', 'DEVICE11', 'DEVICE12', '_AIR_', '_AIR_', '_AIR_']<br>

## show l1_interface
Displays detailed information on all L1 interfaces for each device.
 ```bash
python [file path]/network_sketcher.py show l1_interface　--master [master file path]
 ```
* ex.<br>
＃python .\network_sketcher.py show l1_interface　--master "C:\work\\[MASTER]test.xlsx"<br>
['DEVICE1', 'GE 0/0', 'GigabitEthernet 0/0', 'Auto', 'Auto', '1000BASE-T']<br>
['DEVICE1', 'GE 0/2', 'GigabitEthernet 0/2', 'Auto', 'Auto', '1000BASE-T']<br>
['DEVICE1', 'GE 0/4', 'GigabitEthernet 0/4', 'Auto', 'Auto', '1000BASE-T']<br>
['DEVICE10', 'GE 0/5', 'GigabitEthernet 0/5', 'Auto', 'Auto', '1000BASE-T']<br>

## show L1_link
Displays Layer 1 (L1) physical wiring information per link.
- Each output line represents one physical link.
- Each line contains two endpoints: '[[Device-A, Interface-A], [Device-B, Interface-B]].
- The left/right order in the output is not meaningful (either endpoint may appear on the left).
- Therefore, when identifying or deleting a link, you can treat either endpoint (device + interface) as the “from” side.
 ```bash
python [file path]/network_sketcher.py show l1_link　--master [master file path]
 ```
* ex.<br>
＃python .\network_sketcher.py show l1_link　--master "C:\work\\[MASTER]test.xlsx"<br>
'[['DEVICE1', 'GigabitEthernet 0/0'], ['DEVICE4', 'GigabitEthernet 0/0']]<br>
'[['DEVICE1', 'GigabitEthernet 0/4'], ['DEVICE5', 'GigabitEthernet 0/4']]<br>
'[['DEVICE10', 'GigabitEthernet 0/5'], ['DEVICE4', 'GigabitEthernet 0/5']]<br>

- Notes
    - show l1_link shows only existing links. Interfaces that are not connected by an L1 link will not appear.
    - To delete an L1 link, specify one endpoint (device + interface). The peer endpoint will be determined automatically by the tool (see delete l1_link).


## show l2_broadcast_domain
Displays the name of the Layer 2 segment included in each broadcast domain.

 ```bash
python [file path]/network_sketcher.py show l2_boradcast_domain　--master [master file path]
 ```
* ex.<br>
＃python .\network_sketcher.py show l2_broadcast_domain　--master "C:\work\\[MASTER]test.xlsx"<br>
[[[1], ['Sever-13~1~', 'vlan300']]]<br>
[[2, 3, 4, 5], [['Sever-14~1~', 'vlan800'], ['WAN-Dum3', 'L2SEGMENT']]]<br>
<br>
    *The first element, [1], represents the identifier of the broadcast domain; the second element, ['Sever-13~1~', 'vlan300'], represents the name of the Layer 2 segment connected to that broadcast domain. On the left is the device name and on the right is the Layer 2 segment name. <br>
The second line is similar. The broadcast domain with identifiers [2, 3, 4, 5] has Layer 2 segments ['Sever-14~1~', 'vlan800'], ['WAN-Dum3', 'L2SEGMENT'] connected to it.


## show l2_interface
Displays detailed information about the L2 interface, exported from the input-ready information in the DEVICE file.
 ```bash
python [file path]/network_sketcher.py show l2_interface　--master [master file path]
 ```
* ex.<br>
＃python .\network_sketcher.py show l2_interface　--master "C:\work\\[MASTER]test.xlsx"<br>
['FW-12', 'GigabitEthernet 0/32', '', '', '']<br>
['FW-12', 'GigabitEthernet 0/33', '', '', '']<br>
['FW-12', 'GigabitEthernet 0/36', '', '', '']<br>
['FW-12', 'GigabitEthernet 0/37', '', '', '']<br>


## show l3_broadcast_domain
Displays the Layer 3 interface names included in each broadcast domain.

 ```bash
python [file path]/network_sketcher.py show l3_boradcast_domain　--master [master file path]
 ```
* ex.<br>
＃python .\network_sketcher.py show l3_broadcast_domain　--master "C:\work\\[MASTER]test.xlsx"<br>
[[45], [['Sever-14~1~', 'Loopback 0']]]<br>
[[48, 55], [['FW-12~2~', 'GigabitEthernet 0/24'], ['Sever-13~2~', 'GigabitEthernet 0/24']]]<br>
<br>
    *The first element, [45], represents the identifier of the broadcast domain; the second element, ['Sever-14~1~', 'Loopback 0'], represents the Layer 3 interface connected to that broadcast domain. On the left is the device name and on the right is the Layer 3 interface name. <br>
The second line is similar. The broadcast domain with the identifier [48, 55] has two Layer 3 interfaces connected to it, ['FW-12~2~', 'GigabitEthernet 0/24'] and ['Sever-13~2~', 'GigabitEthernet 0/24'].


## show l3_interface
Displays detailed information about the L3 interface, exported from the input-ready information in the DEVICE file.
 ```bash
python [file path]/network_sketcher.py show l3_interface　--master [master file path]
 ```
* ex.<br>
＃python .\network_sketcher.py show l3_interface　--master "C:\work\\[MASTER]test.xlsx"<br>
['FW-12', 'GigabitEthernet 0/32', '', '10.0.2.1/29']<br>
['FW-12', 'GigabitEthernet 0/33', '', '10.0.2.9/29']<br>
['FW-12', 'GigabitEthernet 0/36', '', '10.0.2.17/29']<br>
['FW-12', 'GigabitEthernet 0/37', '', '10.0.2.25/29']<br>
['FW-12', 'GigabitEthernet 0/38', '', '10.0.5.57/29']<br>


## show waypoint
Displays all waypoint names.
 ```bash
python [file path]/network_sketcher.py show waypoint　--master [master file path]
 ```
* ex.<br>
＃python .\network_sketcher.py show waypoint　--master "C:\work\\[MASTER]test.xlsx"<br>
WAN-1<br>
WAN-Dum3<br>

## show waypoint_interface
Displays all interface names for each waypoint.
 ```bash
python [file path]/network_sketcher.py show waypoint_interface　--master [master file path]
 ```
* ex.<br>
＃python .\network_sketcher.py show waypoint_interface　--master "C:\work\\[MASTER]test.xlsx"<br>
['WAN-1', ['GigabitEthernet 0/0', 'GigabitEthernet 0/19', 'GigabitEthernet 0/31', 'GigabitEthernet 0/45', 'GigabitEthernet 0/46', 'GigabitEthernet 0/53', 'GigabitEthernet 0/54']]<br>
['WAN-Dum3', ['GigabitEthernet 0/6', 'GigabitEthernet 0/10', 'GigabitEthernet 0/13', 'GigabitEthernet 0/14', 'GigabitEthernet 0/26']]<br>



'''
Add Commands reference
'''

**Since this process will directly edit the master file, please be sure to back up the master file before proceeding.**<br>
## What you can do with these steps
**You can execute the following "add" command from the CLI.**
- [add area_location](https://github.com/cisco-open/network-sketcher/wiki/8%E2%80%902-Add-Commands#add-area_location)  *Added in Ver 2.6.1
- [add device](https://github.com/cisco-open/network-sketcher/wiki/8%E2%80%902-Add-Commands#add-device)  *Added in Ver 2.6.1
- [add device_location](https://github.com/cisco-open/network-sketcher/wiki/8%E2%80%902-Add-Commands#add-device_location)  *Added in Ver 2.6.1
- [add ip_address](https://github.com/cisco-open/network-sketcher/wiki/8%E2%80%902-Add-Commands#add-ip_address)
- [add l1_link](https://github.com/cisco-open/network-sketcher/wiki/8%E2%80%902-Add-Commands#add-l1_link)  *Added in Ver 2.6.1
- [add l1_link_bulk](https://github.com/cisco-open/network-sketcher/wiki/8%E2%80%902-Add-Commands#add-l1_link_bulk)  *Added in Ver 2.6.1
- [add l2_segment](https://github.com/cisco-open/network-sketcher/wiki/8%E2%80%902-Add-Commands#add-l2_segment)
- [add portchannel](https://github.com/cisco-open/network-sketcher/wiki/8%E2%80%902-Add-Commands#add-portchannel)
- [add virtual_port](https://github.com/cisco-open/network-sketcher/wiki/8%E2%80%902-Add-Commands#add-virtual_port)
- [add vport_l1if_direct_binding](https://github.com/cisco-open/network-sketcher/wiki/8%E2%80%902-Add-Commands#add-vport_l1if_direct_binding)
- [add vport_l2_direct_binding](https://github.com/cisco-open/network-sketcher/wiki/8%E2%80%902-Add-Commands#add-vport_l2_direct_binding)
- [add waypoint](https://github.com/cisco-open/network-sketcher/wiki/8%E2%80%902-Add-Commands#add-waypoint)  *Added in Ver 2.6.1

## Basic syntax:
 ```bash
python [file path]/network_sketcher.py [command] --master [master file path]
 ```
* The part marked as [command] 、--master [master file path] below can be modified.<br>
python [file path]/network_sketcher.py -master [master file path] [command]<br>

## add area_location

Updates the overall area layout (placement map). By specifying area placement using a two-dimensional array, you can change the relative positions of areas in bulk. New areas can also be added simultaneously.


 ```bash
python [file path]/network_sketcher.py add area_location “[[‘area_name1’,'area_name2'],[‘area_name3’,'area_name4']]” --master [master file path]
 ```
* ex.<br>

+BEFORE+ <br>
#python .\network_sketcher.py show area_location --master “C:\work\[MASTER]test.xlsx”<br>
<code>[[‘DC1’, ‘DC2’]]</code><br>


+area_location updated+ <br>
<code>#python .\network_sketcher.py add area_location “`[‘DC1’,'DC2'],[‘DC3’,'DC4']]'` --master ”C:\work\[MASTER]test.xlsx"</code><br>
--- Area layout updated ---<br>
New areas added: [‘DC3’, ‘DC4’]<br>
  Device added for DC3: DC3_device_<br>
  Device added for DC4: DC4_device_<br>
New area layout:<br>
  [‘DC1’, ‘DC2’]<br>
  [‘DC3’, ‘DC4’]<br>


+AFTER+ <br>
#python .\network_sketcher.py show area_location --master “C:\work\[MASTER]test.xlsx”<br>
<code>[[‘DC1’, ‘DC2’], [‘DC3’, ‘DC4’]]</code><br>


[Tips]
* All existing areas must be included in the new layout
* New areas automatically have default devices added (Standard areas: [area_name]\_device_, Waypoint areas: [area_name] minus _wp_)
* Waypoint-only areas (area names ending with _wp_) cannot be placed side-by-side

## add device

Adds a new device in the specified direction relative to an existing device. The device is added to a normal area (non-waypoint area).

```bash
python [file path]/network_sketcher.py add device [new_device_name] [reference_device] [direction] --master [master file path]
```

[direction] options:


UP : Add above the reference device<br>
DOWN : Add below the reference device<br>
LEFT : Add to the left of the reference device<br>
RIGHT : Add to the right of the reference device<br>
UP_WITH_GRID : Add a row above the reference device<br>
DOWN_WITH_GRID : Place by adding rows below the reference device<br>
LEFT_WITH_GRID : Place by adding columns to the left of the reference device<br>
RIGHT_WITH_GRID : Place by adding columns to the right of the reference device<br>

* ex.<br>

+BEFORE+ <br>
#python .\network_sketcher.py show device_location --master “C:\work\[MASTER]test.xlsx”<br>
<code>[‘_tmp_’, [[‘sw1’, ‘sw2’]]]</code><br>


+device added+ <br>
#python .\network_sketcher.py add device ‘sw4’ 'sw1' RIGHT --master “C:\work\[MASTER]test.xlsx”<br>
--- Device added --- sw4 relative to sw1 with direction RIGHT<br>


+AFTER+ <br>
#python .\network_sketcher.py show device --master “C:\work\[MASTER]test.xlsx”<br>
<code>[‘_tmp_’, [[‘sw1’, ‘sw4’, ‘sw2’]]]</code><br>


[Tips]

* Device names added cannot duplicate existing device names
* Devices placed within a waypoint area cannot be used as reference points

## add device_location

Updates device placement within a specific area. You can change device positions within the area in bulk by specifying the grid layout of devices using a two-dimensional array. All existing devices will be replaced.


 ```bash
python [file path]/network_sketcher.py add device_location “[‘area_name’,[[‘device_name1’,'device2_name'],[‘device_name3’,'device_name4']]]” --master [master file path]
 ```

ex.<br>

+BEFORE+ <br>
#python .\network_sketcher.py show device_location --master “C:\work\[MASTER]test.xlsx”<br>
<code>[‘DC1’, [[‘SW-1’, ‘SW-2’]]]</code><br>


+device_location updated+ <br>
<code>#python .\network_sketcher.py add device_location “[‘DC1’,[[‘SW-1’,'SW-2'],[‘SW-3’,'AIR']]]” --master “C:\work\[MASTER]test.xlsx”</code><br>
--- Device location updated for area “DC1” ---<br>
Added devices: [‘SW-3’]<br>
New device layout (normalized):<br>
  [‘SW-1’, ‘SW-2’]<br>
  [‘SW-3’, ‘AIR’]<br>


+AFTER+ <br>
#python .\network_sketcher.py show device_location --master “C:\work\[MASTER]test.xlsx”<br>
<code>[‘DC1’, [[‘SW-1’, ‘SW-2’], [‘SW-3’, ‘AIR’]]]</code><br>


[Tips]

* Device grid is automatically centered and normalized
* Use \_AIR\_ to explicitly specify empty cells
* An error occurs if a new device already exists in another area
* Only device placement changes (no additions or deletions) are also possible

## add ip_address
This process allows you to create an IP address for a Layer 3 interface. You can create one IP address at a time; by repeating the process, you can add multiple IP addresses.
 ```bash
python [file path]/network_sketcher.py add ip_address [device name] [layer3_portname] [ip_address/subnetmask] --master [master file path]
 ```

* ex.<br>

**+BEFORE+ <br>**
#python .\network_sketcher.py show l3_interface --master "C:\work\\[MASTER]test.xlsx"<br>
['L3SW2', 'Vlan 100', '', '']<br>

**+IP Address added+ <br>**
＃python .\network_sketcher.py add ip_address 'L3SW2' 'Vlan 100' '192.168.100.100/24' --master "C:\work\\[MASTER]test.xlsx"<br>
--- IP Address added ---  L3SW2,Vlan 100,192.168.100.100/24<br>

**+AFTER+ <br>**
#python .\network_sketcher.py show l3_interface --master "C:\work\\[MASTER]test.xlsx"<br>
['L3SW2', 'Vlan 100', '', '192.168.100.100/24']<br>


## add l1_link

Creates a Layer 1 physical connection between devices. Only one physical link can be created at a time. Multiple links can be added by repeating the process.

 ```bash
python [file path]/network_sketcher.py add l1_link [from_device] [to_device] [from_portname] [to_portname] --master [master file path]
 ```

* ex.<br>

+BEFORE+ <br>
#python .\network_sketcher.py show l1_link --master “C:\work\[MASTER]test.xlsx”<br>
<code>[[‘SW-1’, ‘GigabitEthernet 0/0’], [‘SW-3’, ‘GigabitEthernet 0/1’]]</code><br>

+l1_link added+ <br>
#python .\network_sketcher.py add l1_link ‘SW-1’ 'SW-2' ‘GigabitEthernet 0/1’ 'GigabitEthernet 0/0' --master “C:\work\[MASTER]test.xlsx”<br>
--- Added Layer 1 link --- SW-1 SW-2 GigabitEthernet 0/1 GigabitEthernet 0/0<br>

+AFTER+ <br>
#python .\network_sketcher.py show l1_link --master “C:\work\[MASTER]test.xlsx”<br>
<code>[[‘SW-1’, ‘GigabitEthernet 0/0’], [‘SW-3’, ‘GigabitEthernet 0/1’]]</code><br>
<code>[[‘SW-1’, ‘GigabitEthernet 0/1’], [‘SW-2’, ‘GigabitEthernet 0/0’]]</code><br>

[Tips]

* Port names contain spaces, so they must be enclosed in single quotes (‘port 0’).


## add l1_link_bulk

Creates multiple Layer 1 physical connections in bulk. Specify multiple link definitions in array format to efficiently add multiple links.

 ```bash
python [file path]/network_sketcher.py add l1_link_bulk “[[‘from_device1’,'to_device1',‘from_port1’,'to_port1'],[‘from_device2’,'to_device2',‘from_port2’,'to_port2']]” --master [master file path]
```

* ex.<br>

+BEFORE+ <br>
#python .\network_sketcher.py show l1_link --master “C:\work\[MASTER]test.xlsx”<br>
<code>[[‘SW-1’, ‘GigabitEthernet 0/0’], [‘SW-3’, ‘GigabitEthernet 0/1’]]</code><br>


+l1_link_bulk added+<br>
<code>#python .\network_sketcher.py add l1_link_bulk "[[‘SW-1’,'SW-2',‘GigabitEthernet 0/1’,'GigabitEthernet 0/0'], [‘SW-2’,'SW-3',‘GigabitEthernet 0/1’,'GigabitEthernet 0/2']]“ --master ”C:\work\[MASTER]test.xlsx"</code><br>
--- Added 2 Layer 1 link(s) in bulk ---<br>
  SW-1(GigabitEthernet 0/1) ↔ SW-2(GigabitEthernet 0/0)<br>
  SW-2(GigabitEthernet 0/1) ↔ SW-3(GigabitEthernet 0/2)<br>
Affected devices: [‘SW-1’, ‘SW-2’, ‘SW-3’]<br>

+AFTER+ <br>
#python .\network_sketcher.py show l1_link --master “C:\work\[MASTER]test.xlsx”<br>
<code>[[‘SW-1’, ‘GigabitEthernet 0/0’], [‘SW-3’, ‘GigabitEthernet 0/1’]]</code><br>
<code>[[‘SW-1’, ‘GigabitEthernet 0/1’], [‘SW-2’, ‘GigabitEthernet 0/0’]]</code><br>
<code>[[‘SW-2’, ‘GigabitEthernet 0/1’], [‘SW-3’, ‘GigabitEthernet 0/2’]]</code><br>

[Tips]

* All elements (device names, port names) must be enclosed in single or double quotes
* Using the same port multiple times within a batch will cause an error
* Ports already in use by existing links cannot be used


## add l2_segment
This feature allows you to create Layer 2 segments (such as VLANs) on the interface. You can create one Layer 2 segment at a time, and multiple Layer 2 segments can be created.
 ```bash
python [file path]/network_sketcher.py add l2_segment [device name] [layer2_portname] [l2segment_name]　--master [master file path]
 ```

* ex.<br>

**+BEFORE+ <br>**
#python .\network_sketcher.py show l3_interface --master "C:\work\\[MASTER]test.xlsx"<br>
['L3SW2', 'GigabitEthernet 0/0', '', 'Vlan100,Vlan200,Vlan300', '']<br>

**+l2_segment added+ <br>**
＃python .\network_sketcher.py add l2_segment 'L3SW2' 'GigabitEthernet 0/0' 'addvlan999' --master "C:\work\\[MASTER]test.xlsx"<br>
--- l2 Segment added ---  L3SW2,GigabitEthernet 0/0,addvlan999<br>

**+AFTER+ <br>**
#python .\network_sketcher.py show l3_interface --master "C:\work\\[MASTER]test.xlsx"<br>
['L3SW2', 'GigabitEthernet 0/0', '', 'Vlan100,Vlan200,Vlan300,addvlan999', '']<br>

## add portchannel
Create a port channel (LAG) on the Layer 1 interface.
 ```bash
python [file path]/network_sketcher.py add portchannel [device name] [layer1_portname] [portchannel_name]　--master [master file path]
 ```

* ex.<br>

**+BEFORE+ <br>**
#python .\network_sketcher.py show l2_interface --master "C:\work\\[MASTER]test.xlsx"<br>
['L3SW1', 'GigabitEthernet 0/0', '', '', '']<br>
['L3SW1', 'GigabitEthernet 0/1', '', '', '']<br>

#python .\network_sketcher.py show l3_interface --master "C:\work\\[MASTER]test.xlsx"<br>
['L3SW1', 'GigabitEthernet 0/0', '', '']<br>
['L3SW1', 'GigabitEthernet 0/1', '', '']<br>

**+portchannel added+ <br>**
＃python .\network_sketcher.py add portchannel 'L3SW1' 'GigabitEthernet 0/0' 'PortChannel 1' --master "C:\work\\[MASTER]test.xlsx"<br>
--- portchannel added ---  L3SW1,GigabitEthernet 0/0,PortChannel 1<br>
＃python .\network_sketcher.py add portchannel 'L3SW1' 'GigabitEthernet 0/1' 'PortChannel 1' --master "C:\work\\[MASTER]test.xlsx"<br>
--- portchannel added ---  L3SW1,GigabitEthernet 0/1,PortChannel 1<br>

**+AFTER+ <br>**
#python .\network_sketcher.py show l2_interface --master "C:\work\\[MASTER]test.xlsx"<br>
['L3SW1', 'GigabitEthernet 0/0', 'PortChannel 1', '', '']<br>
['L3SW1', 'GigabitEthernet 0/1', 'PortChannel 1', '', '']<br>

#python .\network_sketcher.py show l3_interface --master "C:\work\\[MASTER]test.xlsx"<br>
['L3SW1', 'PortChannel 1', '', '']<br>


## add virtual_port
Create Layer 3 virtual interfaces, such as VLAN interfaces (SVIs).After creating a virtual port, it will be in loopback address state, so if you want to connect to a layer 2 segment such as a VLAN, execute the add l2_segment command to connect the created virtual port to the l2_segment.
 ```bash
python [file path]/network_sketcher.py add virtual_port [device name] [virtual_portname] --master [master file path]
 ```

* ex.<br>

**+BEFORE+ <br>**
#python .\network_sketcher.py show l2_interface --master "C:\work\\[MASTER]test.xlsx"<br>
['L3SW2', '', 'Vlan 300', 'Vlan300', '']<br>

#python .\network_sketcher.py show l3_interface --master "C:\work\\[MASTER]test.xlsx"<br>
['L3SW2', 'Vlan 300', '', '']<br>

**+virtual_port added+ <br>**
＃python .\network_sketcher.py add virtual_port 'L3SW2' 'addvlan 999' --master "C:\work\\[MASTER]test.xlsx"<br>
--- Virtual Port  added ---  L3SW2,addvlan 999<br>

**+AFTER+ <br>**
#python .\network_sketcher.py show l2_interface --master "C:\work\\[MASTER]test.xlsx"<br>
['L3SW2', '', 'addvlan 999', '', '']<br>
['L3SW2', '', 'Vlan 300', 'Vlan300', '']<br>

#python .\network_sketcher.py show l3_interface --master "C:\work\\[MASTER]test.xlsx"<br>
['L3SW2', 'Vlan 300', '', '']<br>
['L3SW2', 'addvlan 999', '', '']<br>

## add vport_l1if_direct_binding
This adds a virtual port that connects directly to a layer 1 interface. For example, this is used when creating subinterfaces on a router and configuring dot1q tagging for each subinterface. It is also possible to configure multiple virtual ports to be connected to a single layer 1 interface. This setting alone only creates a subinterface, so to send and receive layer 2 data, you must add add vport_l2_direct_binding to this setting and add layer 2 elements such as VLANs to the virtual port created.
 ```bash
python [file path]/network_sketcher.py add vport_l1if_direct_binding [device name] [Layer1 port] [vport_name_direct_binding] --master [master file path]
 ```
* ex.<br>

**+BEFORE+ <br>**
#python .\network_sketcher.py show l2_interface --master "C:\work\\[MASTER]test.xlsx"<br>
['Catalyst 3560', 'GigabitEthernet 0/0', '', '', '']<br>

**+vport_l1if_direct_binding added+ <br>**
＃python .\network_sketcher.py add vport_l1if_direct_binding "Catalyst 3560" "GigabitEthernet 0/0" "GigabitEthernet 0/0.100"  --master "C:\work\\[MASTER]test.xlsx"<br>
--- vport_l1if_direct_binding added ---  Catalyst 3560,GigabitEthernet 0/0,GigabitEthernet 0/0.100<br>

**+AFTER+ <br>**
#python .\network_sketcher.py show l2_interface --master "C:\work\\[MASTER]test.xlsx"<br>
['Catalyst 3560', 'GigabitEthernet 0/0', 'GigabitEthernet 0/0.100', '', '']<br>

## add vport_l2_direct_binding
This command allows a virtual port to directly send and receive Layer 2 data such as VLANs. Normally, a virtual port is connected to an l2_segment, and then that l2_segment is connected to a Layer 1 interface, thereby connecting the Layer 1 interface and the virtual port. However, this command directly connects a virtual port to a Layer 1 interface, allowing Layer 2 elements such as VLANs (l2_segment) to be sent and received. For example, this command is used when creating subinterfaces on a router and configuring dot1q tagging for each subinterface. It is also possible to configure a single virtual port to send and receive Layer 2 data such as multiple VLANs. Note that l2_segment and vport_l2_direct_binding cannot be registered simultaneously on the same virtual port.
 ```bash
python [file path]/network_sketcher.py add vport_l2_direct_binding [device name] [virtual port] [l2_name_direct_binding] --master [master file path]
 ```
* ex.<br>

**+BEFORE+ <br>**
#python .\network_sketcher.py show l2_interface --master "C:\work\\[MASTER]test.xlsx"<br>
['Catalyst 3560', 'GigabitEthernet 0/0', 'GigabitEthernet 0/0.100', '', '']<br>

**+virtual_port added+ <br>**
＃python .\network_sketcher.py add vport_l2_direct_binding "Catalyst 3560" "GigabitEthernet 0/0.100" vlan100 --master "C:\work\\[MASTER]test.xlsx"<br>
--- vport_l2_direct_binding added ---  Catalyst 3560,GigabitEthernet 0/0.100,vlan100<br>

**+AFTER+ <br>**
#python .\network_sketcher.py show l2_interface --master "C:\work\\[MASTER]test.xlsx"<br>
['Catalyst 3560', 'GigabitEthernet 0/0', 'GigabitEthernet 0/0.100', '', 'vlan100']<br>


## add waypoint

Adds a new waypoint in the specified direction relative to an existing waypoint. Waypoints are added to the dedicated waypoint area (area names ending with _wp_).

```bash
python [file path]/network_sketcher.py add waypoint [new_waypoint_name] [reference_waypoint] [direction] --master [master file path]
 ```

[direction] specifications:

UP : Add above the reference waypoint<br>
DOWN : Add below the reference waypoint<br>
LEFT : Add to the left of the reference waypoint<br>
RIGHT : Add to the right of the reference waypoint<br>

* ex.<br>

+BEFORE+ <br>
#python .\network_sketcher.py show waypoint_location --master “C:\work\[MASTER]test.xlsx”<br>
<code>[‘WAN-1_wp_’, [[‘WAN-1’]]]</code><br>


+waypoint added+ <br>
#python .\network_sketcher.py add waypoint ‘WAN-2’ 'WAN-1' ‘RIGHT’ --master “C:\work\[MASTER]test.xlsx”<br>
--- Waypoint added --- WAN-2 relative to WAN-1 with direction RIGHT<br>


+AFTER+ <br>
#python .\network_sketcher.py show waypoint_location --master “C:\work\[MASTER]test.xlsx”<br>
<code>[‘WAN-1_wp_’, [[‘WAN-1’, ‘WAN-2’]]]</code><br>


[Tips]

* Waypoints are always placed within dedicated waypoint areas (area names ending with _wp_)
* An error occurs if the reference device is not present in a dedicated waypoint area
* If a regular area exists adjacent to the X-axis, only UP/DOWN can be used
* If all areas adjacent to the X-axis are waypoint areas or empty, only LEFT/RIGHT can be used




'''
Delete Commands reference
'''
**Since this process will directly edit the master file, please be sure to back up the master file before proceeding.**<br>

## What you can do with these steps
**You can execute the following "add" command from the CLI.**
- [delete area](https://github.com/cisco-open/network-sketcher/wiki/8%E2%80%903-Delete-Commands#delete-area) *Added in Ver 2.6.1
- [delete ip_address](https://github.com/cisco-open/network-sketcher/wiki/8‐3-Delete-Commands#delete-ip_address)
- [delete l1_link](https://github.com/cisco-open/network-sketcher/wiki/8%E2%80%903-Delete-Commands#delete-l1_link) *Added in Ver 2.6.1
- [delete l2_segment](https://github.com/cisco-open/network-sketcher/wiki/8‐3-Delete-Commands#delete-l2_segment)
- [delete portchannel](https://github.com/cisco-open/network-sketcher/wiki/8%E2%80%903-Delete-Commands#delete-portchannel)
- [delete virtual_port](https://github.com/cisco-open/network-sketcher/wiki/8‐3-Delete-Commands#delete-virtual_port)
- [delete vport_l1if_direct_binding](https://github.com/cisco-open/network-sketcher/wiki/8%E2%80%903-Delete-Commands#delete-vport_l1if_direct_binding)
- [delete vport_l2_direct_binding](https://github.com/cisco-open/network-sketcher/wiki/8%E2%80%903-Delete-Commands#delete-vport_l2_direct_binding)
- [delete waypoint](https://github.com/cisco-open/network-sketcher/wiki/8%E2%80%903-Delete-Commands#delete-waypoint) *Added in Ver 2.6.1

## Basic syntax:
 ```bash
python [file path]/network_sketcher.py [command] --master [master file path]
 ```
* The part marked as [command] 、--master [master file path] below can be modified.<br>
python [file path]/network_sketcher.py -master [master file path] [command]<br>

## delete area

Deletes the entire area. All devices within the area, along with their interface settings and connections, will also be deleted.

```bash
python [file path]/network_sketcher.py delete area [area_name] --master [master file path]
```

* ex.<br>

+BEFORE+

#python .\network_sketcher.py show area_location --master “C:\work\[MASTER]test.xlsx”<br>
<code>[[‘DC1’, ‘DC2’], [‘DC3’, ‘DC4’]]</code>

+area deleted+

#python .\network_sketcher.py delete area ‘DC3’ --master “C:\work\[MASTER]test.xlsx”<br>
--- Area deleted --- DC3<br>
Devices removed: [‘DC3_device_’, ‘SW-3’]<br>
All associated links and configurations have been removed.

+AFTER+

#python .\network_sketcher.py show area_location --master “C:\work\[MASTER]test.xlsx”<br>
<code>[[‘DC1’, ‘DC2’], [‘DC4’]]</code>
<br><br>
[Tips]

* All devices within the area will be deleted
* All Layer 1 links connected to the deleted devices will also be removed
* The area layout will be automatically updated
* Waypoint-specific areas (area names ending with _wp_) can also be deleted

## delete ip_address
This function deletes the IP address of a Layer 3 interface. You can delete one IP address at a time.
 ```bash
python [file path]/network_sketcher.py delete ip_address [device name] [layer3_portname] [ip_address/subnetmask] --master [master file path]
 ```

* ex.<br>

**+BEFORE+ <br>**
#python .\network_sketcher.py show l3_interface --master "C:\work\\[MASTER]test.xlsx"<br>
['L3SW2', 'Vlan 100', '', '192.168.100.100/24']<br>

**+IP Address deleted+ <br>**
＃python .\network_sketcher.py delete ip_address 'L3SW2' 'Vlan 100' '192.168.100.100/24' --master "C:\work\\[MASTER]test.xlsx"<br>
--- IP Address deleted ---  L3SW2,Vlan 100,192.168.100.100/24<br>

**+AFTER+ <br>**
#python .\network_sketcher.py show l3_interface --master "C:\work\\[MASTER]test.xlsx"<br>
['L3SW2', 'Vlan 100', '', '']<br>



## delete device

This command deletes the specified device, along with all Layer 1 links connected to the deleted device.

 ```bash
python [file path]/network_sketcher.py delete device [device_name] --master [master file path]
 ```

ex.<br>

+BEFORE+

#python .\network_sketcher.py show device --master "C:\work[MASTER]test.xlsx"<br>
<code>['DC1_device_', 'L3SW1', 'L3SW2', 'SW-1', 'SW-2', 'SW-3']</code>

#python .\network_sketcher.py show l1_link --master "C:\work[MASTER]test.xlsx"<br>
<code>[['SW-1', 'GigabitEthernet 0/0'], ['SW-3', 'GigabitEthernet 0/1']]</code>
<code>[['SW-1', 'GigabitEthernet 0/1'], ['SW-2', 'GigabitEthernet 0/0']]</code>
<code>[['SW-2', 'GigabitEthernet 0/1'], ['L3SW1', 'GigabitEthernet 0/0']]</code>

+device deleted+

#python .\network_sketcher.py delete device 'SW-2' --master "C:\work[MASTER]test.xlsx"<br>
--- Device deleted --- SW-2


+AFTER+

#python .\network_sketcher.py show device --master "C:\work[MASTER]test.xlsx"<br>
<code>['DC1_device_', 'L3SW1', 'L3SW2', 'SW-1', 'SW-3']</code>


#python .\network_sketcher.py show l1_link --master "C:\work[MASTER]test.xlsx"<br>
<code>[['SW-1', 'GigabitEthernet 0/0'], ['SW-3', 'GigabitEthernet 0/1']]</code>
<br><br>

[Tips]

* All Layer 1 links connected to the deleted device will also be deleted.
* If it is the last device in an area, it cannot be deleted (use the delete area command).
* If it is a waypoint (a device in an area ending in _wp_), use the delete waypoint command.



## delete l1_link

Deletes the Layer 1 physical connection between devices. All associated Layer 2 and Layer 3 configurations on the deleted interface are automatically removed. Only one physical link can be deleted at a time.

```bash
python [file path]/network_sketcher.py delete l1_link [from_device] [from_portname] --master [master file path]
```

* ex.<br>

+BEFORE+


#python .\network_sketcher.py show l1_link --master “C:\work\[MASTER]test.xlsx”<br>
<code>[[‘SW-1’, ‘GigabitEthernet 0/0’], [‘SW-3’, ‘GigabitEthernet 0/1’]]</code>
<code>[[‘SW-1’, ‘GigabitEthernet 0/1’], [‘SW-2’, ‘GigabitEthernet 0/0’]]</code>

+l1_link deleted+

#python .\network_sketcher.py delete l1_link ‘SW-1’ 'GigabitEthernet 0/1' --master “C:\work\[MASTER]test.xlsx”<br>
--- Layer 1 link deleted --- SW-1 GigabitEthernet 0/1 <-> SW-2 GigabitEthernet 0/0

+AFTER+


#python .\network_sketcher.py show l1_link --master “C:\work\[MASTER]test.xlsx”<br>
<code>[[‘SW-1’, ‘GigabitEthernet 0/0’], [‘SW-3’, ‘GigabitEthernet 0/1’]]</code>
<br><br>
[Tips]


- Cascade deletion: Deleting an L1 link automatically deletes the following: Any other Layer 2 and Layer 3 configurations are also deleted.:
    - Port-channel membership (if the interface is a member)
    - L2 segments (VLANs) configured on the interface
    - Subinterfaces (virtual ports) bound to the interface
    - IP addresses on subinterfaces
    - The entire Port-channel and its L3 configuration if all member interfaces are deleted
- Specify only the from device and from port name (to device/to port are automatically determined)
- Since the port name contains spaces, it must be enclosed in single quotes ('port 0')
- Use with caution: This single command can remove extensive Layer 2/Layer 3 configurations



## delete l2_segment
This function deletes the Layer 2 segment (such as VLAN) configured on the interface. You can delete one Layer 2 segment at a time.
 ```bash
python [file path]/network_sketcher.py delete l2_segment [device name] [layer2_portname] [l2segment_name] --master [master file path]
 ```

* ex.<br>

**+BEFORE+ <br>**
#python .\network_sketcher.py show l3_interface --master "C:\work\\[MASTER]test.xlsx"<br>
['L3SW2', 'GigabitEthernet 0/0', '', 'Vlan100,Vlan200,Vlan300,addvlan999', '']<br>

**+l2_segment deleted+ <br>**
＃python .\network_sketcher.py delete l2_segment 'L3SW2' 'GigabitEthernet 0/0' 'addvlan999' --master "C:\work\\[MASTER]test.xlsx"<br>
--- l2 Segment deleted ---  L3SW2,GigabitEthernet 0/0,addvlan999<br>

**+AFTER+ <br>**
#python .\network_sketcher.py show l3_interface --master "C:\work\\[MASTER]test.xlsx"<br>
['L3SW2', 'GigabitEthernet 0/0', '', 'Vlan100,Vlan200,Vlan300', '']<br>

## delete portchannel
The port channel (LAG) configured on the Layer 1 interface will be deleted, along with the Layer 2 segment configured on the port channel.
 ```bash
python [file path]/network_sketcher.py delete portchannel [device name] [layer1_portname] --master [master file path]
 ```

* ex.<br>

**+BEFORE+ <br>**
#python .\network_sketcher.py show l2_interface --master "C:\work\\[MASTER]test.xlsx"<br>
['L3SW1', 'GigabitEthernet 0/0', 'PortChannel 1', 'vlan1', '']<br>
['L3SW1', 'GigabitEthernet 0/1', 'PortChannel 1', 'vlan1', '']<br>

#python .\network_sketcher.py show l3_interface --master "C:\work\\[MASTER]test.xlsx"<br>
['L3SW1', 'PortChannel 1', '', '']<br>

**+portchannel deleted+ <br>**
＃python .\network_sketcher.py delete portchannel 'L3SW1' 'GigabitEthernet 0/0' --master "C:\work\\[MASTER]test.xlsx"<br>
--- portchannel deleted ---  L3SW1,GigabitEthernet 0/0,PortChannel 1<br>

＃python .\network_sketcher.py delete portchannel 'L3SW1' 'GigabitEthernet 0/1' --master "C:\work\\[MASTER]test.xlsx"<br>
--- portchannel deleted ---  L3SW1,GigabitEthernet 0/1,PortChannel 1<br>

**+AFTER+ <br>**
#python .\network_sketcher.py show l2_interface --master "C:\work\\[MASTER]test.xlsx"<br>
['L3SW1', 'GigabitEthernet 0/0', '', '', '']<br>
['L3SW1', 'GigabitEthernet 0/1', '', '', '']<br>

#python .\network_sketcher.py show l3_interface --master "C:\work\\[MASTER]test.xlsx"<br>
['L3SW1', 'GigabitEthernet 0/0', '', '']<br>
['L3SW1', 'GigabitEthernet 0/1', '', '']<br>


## delete virtual_port
This will delete Layer 3 interfaces such as VLAN interfaces (SVIs).This command cannot be used to delete a port channel.
 ```bash
python [file path]/network_sketcher.py delete virtual_port [device name] [virtual_portname] --master [master file path]
 ```

* ex.<br>

**+BEFORE+ <br>**
#python .\network_sketcher.py show l2_interface --master "C:\work\\[MASTER]test.xlsx"<br>
['L3SW2', '', 'addvlan 999', '', '']<br>
['L3SW2', '', 'Vlan 300', 'Vlan300', '']<br>

#python .\network_sketcher.py show l3_interface --master "C:\work\\[MASTER]test.xlsx"<br>
['L3SW2', 'Vlan 300', '', '']<br>
['L3SW2', 'addvlan 999', '', '']<br>

**+virtual_port deleted+ <br>**
＃python .\network_sketcher.py delete virtual_port 'L3SW2' 'addvlan 999' --master "C:\work\\[MASTER]test.xlsx"<br>
--- Virtual Port deleted ---  L3SW2,addvlan 999<br>

**+AFTER+ <br>**
#python .\network_sketcher.py show l2_interface --master "C:\work\\[MASTER]test.xlsx"<br>
['L3SW2', '', 'Vlan 300', 'Vlan300', '']<br>

#python .\network_sketcher.py show l3_interface --master "C:\work\\[MASTER]test.xlsx"<br>
['L3SW2', 'Vlan 300', '', '']<br>

## delete vport_l1if_direct_binding
This command deletes a virtual port connected to a layer 1 port. This command also deletes layer 2 elements such as VLANs connected to the virtual port.

 ```bash
python [file path]/network_sketcher.py delete vport_l1if_direct_binding [device name] [vport_name_direct_binding] --master [master file path]
 ```
* ex.<br>

**+BEFORE+ <br>**
#python .\network_sketcher.py show l2_interface --master "C:\work\\[MASTER]test.xlsx"<br>
['Catalyst 3560', 'GigabitEthernet 0/0', 'GigabitEthernet 0/0.100', '', 'vlan100']<br>

**+vport_l1if_direct_binding deleted+ <br>**
＃python .\network_sketcher.py delete vport_l1if_direct_binding "Catalyst 3560" "GigabitEthernet 0/0.100" --master "C:\work\\[MASTER]test.xlsx"<br>
--- vport_l1if_direct_binding deleted ---  Catalyst 3560,GigabitEthernet 0/0.100,vlan100<br>

**+AFTER+ <br>**
#python .\network_sketcher.py show l2_interface --master "C:\work\\[MASTER]test.xlsx"<br>
['Catalyst 3560', 'GigabitEthernet 0/0', '', '', '']<br>


## delete vport_l2_direct_binding
Remove elements that send and receive layer 2 traffic, such as VLAN (l2_segment), directly from the virtual port.

 ```bash
python [file path]/network_sketcher.py delete vport_l2_direct_binding [device name] [virtual port] [l2_name_direct_binding] --master [master file path]
 ```
* ex.<br>

**+BEFORE+ <br>**
#python .\network_sketcher.py show l2_interface --master "C:\work\\[MASTER]test.xlsx"<br>
['Catalyst 3560', 'GigabitEthernet 0/0', 'GigabitEthernet 0/0.100', '', 'vlan100']<br>

**+virtual_port deleted+ <br>**
＃python .\network_sketcher.py delete vport_l2_direct_binding "Catalyst 3560" "GigabitEthernet 0/0.100" “vlan100” --master "C:\work\\[MASTER]test.xlsx"<br>
--- vport_l2_direct_binding deleted ---  Catalyst 3560,GigabitEthernet 0/0.100,vlan100<br>

**+AFTER+ <br>**
#python .\network_sketcher.py show l2_interface --master "C:\work\\[MASTER]test.xlsx"<br>
['Catalyst 3560', 'GigabitEthernet 0/0', 'GigabitEthernet 0/0.100', '', '']<br>



## delete waypoint

Deletes a waypoint from the dedicated waypoint area. All Layer 1 links connected to the deleted waypoint will also be deleted simultaneously.

```bash
python [file path]/network_sketcher.py delete waypoint [waypoint_name] --master [master file path]
```

* ex.<br>

+BEFORE+

#python .\network_sketcher.py show waypoint_location --master “C:\work\[MASTER]test.xlsx”<br>
<code>[‘WAN-1_wp_’, [[‘WAN-1’, ‘WAN-2’, ‘WAN-3’]]]</code>

#python .\network_sketcher.py show l1_link --master “C:\work\[MASTER]test.xlsx”<br>
<code>[[‘SW-1’, ‘GigabitEthernet 0/0’], [‘WAN-2’, ‘port 0’]]</code>
<code>[[‘WAN-2’, ‘port 1’], [‘SW-2’, ‘GigabitEthernet 0/0’]]</code>

+Waypoint deleted+

#python .\network_sketcher.py delete waypoint ‘WAN-2’ --master “C:\work\[MASTER]test.xlsx”<br>
--- Waypoint deleted --- WAN-2<br>
Associated links removed: 2<br>

+AFTER+

#python .\network_sketcher.py show waypoint_location --master “C:\work\[MASTER]test.xlsx”<br>
<code>[‘WAN-1_wp_’, [[‘WAN-1’, ‘WAN-3’]]]</code>

#python .\network_sketcher.py show l1_link --master “C:\work\[MASTER]test.xlsx”<br>
(Links connected to WAN-2 have been deleted)

[Tips]

* Waypoints must be placed within dedicated waypoint areas (area names ending with _wp_)
* All Layer 1 links connected to a deleted waypoint will also be deleted
* Regular devices (non-waypoints) cannot be deleted (use the device delete command instead)
* Device placement within waypoint areas is automatically updated









'''
Rename Commands reference
'''
**Since you will be editing the Master file directly, be sure to back up the Master file before proceeding.**

## What you can do with this procedure
**You can run the following rename command from the CLI**
- [rename area](https://github.com/cisco-open/network-sketcher/wiki/8%E2%80%904.-Rename-Commands#rename-area)
- [rename device](https://github.com/cisco-open/network-sketcher/wiki/8%E2%80%904.-Rename-Commands_jp#rename-device)
- [rename l3_instance](https://github.com/cisco-open/network-sketcher/wiki/8%E2%80%904.-Rename-Commands#rename-l3_instance)
- [rename port](https://github.com/cisco-open/network-sketcher/wiki/8%E2%80%904.-Rename-Commands_jp#rename-port)

## Basic Syntax
 ```bash
python [file path]/network_sketcher.py [command] --master [master file path]
 ```
* The location of [command] 、--master [master file path] can be changed as follows:<br>
python [file path]/network_sketcher.py -master [master file path] [command]<br>

## rename area
Change the area name.
 ```bash
python [file path]/network_sketcher.py rename area [Original area name] [Updated area name] --master [master file path]
 ```

* ex.<br>

**+BEFORE+ <br>**
#python .\network_sketcher.py show area --master "C:\work\\[MASTER]test.xlsx"<br>
Area1<br>
Area2<br>
Area3<br>

**+Device renamed+ <br>**
＃python .\network_sketcher.py rename area 'Area3' 'Area99' --master "C:\work\\[MASTER]test.xlsx"<br>
--- Area renamed --- Area3 -> Area99<br>

**+AFTER+ <br>**
#python .\network_sketcher.py show area --master "C:\work\\[MASTER]test.xlsx"<br>
Area1<br>
Area2<br>
Area99<br>

## rename device
Change the device name.
 ```bash
python [file path]/network_sketcher.py rename device [Original device name] [Updated device name] --master [master file path]
 ```

* ex.<br>

**+BEFORE+ <br>**
#python .\network_sketcher.py show device --master "C:\work\\[MASTER]test.xlsx"<br>
L3SW1<br>
L3SW2<br>

**+Device renamed+ <br>**
＃python .\network_sketcher.py rename device 'L3SW1' 'L3SW100' --master "C:\work\\[MASTER]test.xlsx"<br>
--- Device Name renamed ---  L3SW1 -> L3SW100<br>

**+AFTER+ <br>**
#python .\network_sketcher.py show device --master "C:\work\\[MASTER]test.xlsx"<br>
L3SW100<br>
L3SW2<br>

## rename l3_instance
Change the l3_instance, such as the VRF to which the Layer 3 interface belongs. By default, all Layer 3 interfaces are set to blank'' which means "Default" If you change the l3_instance name of one Layer 3 interface, all other l3_instances that are set to blank"" are implicitly set to the "default" l3_instance.

 ```bash
python [file path]/network_sketcher.py rename l3_instance [device name] [layer3 port name] [Renamed l3_instance name] --master [master file path]
 ```

* ex.<br>

**+BEFORE+ <br>**
#python .\network_sketcher.py show l3_interface --master "C:\work\\[MASTER]test.xlsx"<br>
['devcie1', 'GigabitEthernet 0/0', '', '']<br>

**+l3_interface renamed+ <br>**
＃python .\network_sketcher.py rename l3_instance 'devcie1' 'GigabitEthernet 0/0' 'VRF-1' --master "C:\work\\[MASTER]test.xlsx"<br>
--- l3 instance renamed ---  devcie1,GigabitEthernet 0/0,VRF-10<br>

**+AFTER+ <br>**
#python .\network_sketcher.py show l3_interface --master "C:\work\\[MASTER]test.xlsx"<br>
['devcie1', 'GigabitEthernet 0/0', 'VRF-1', '']<br>

## rename port
Change the port name and port number.
 ```bash
python [file path]/network_sketcher.py rename port [device name] [Original port name] [Updated port name] --master [master file path]
 ```

* ex.<br>

**+BEFORE+ <br>**
#python .\network_sketcher.py show l1_interface --master "C:\work\\[MASTER]test.xlsx"<br>
['L3SW1', 'GE 0/0', 'GigabitEthernet 0/0', 'Auto', 'Auto', '1000BASE-T']<br>
['L3SW2', 'GE 0/0', 'GigabitEthernet 0/0', 'Auto', 'Auto', '1000BASE-T']<br>

#python .\network_sketcher.py show l2_interface --master "C:\work\\[MASTER]test.xlsx"<br>
['L3SW1', '', 'Vlan 201', 'Vlan100', '']<br>
['L3SW1', '', 'Vlan 200', 'Vlan200', '']<br>
['L3SW1', '', 'Vlan 300', 'Vlan300', '']<br>
['L3SW1', 'GigabitEthernet 0/0', '', 'Vlan100,Vlan200,Vlan300', '']<br>
['L3SW2', '', 'addvlan 999', '', '']<br>
['L3SW2', '', 'Vlan 201', 'Vlan100', '']<br>
['L3SW2', '', 'Vlan 200', 'Vlan200', '']<br>
['L3SW2', '', 'Vlan 202', 'Vlan300', '']<br>
['L3SW2', 'GigabitEthernet 0/0', '', 'Vlan100,Vlan200,Vlan300', '']<br>

#python .\network_sketcher.py show l3_interface --master "C:\work\\[MASTER]test.xlsx"<br>
['L3SW1', 'Vlan 201', '', '']<br>
['L3SW1', 'Vlan 200', '', '']<br>
['L3SW1', 'Vlan 300', '', '']<br>
['L3SW2', 'Vlan 201', '', '']<br>
['L3SW2', 'Vlan 200', '', '']<br>
['L3SW2', 'Vlan 202', '', '']<br>
['L3SW2', 'addvlan 999', '', '']<br>

**+Port renamed+ <br>**
＃python .\network_sketcher.py rename port 'L3SW1' 'GigabitEthernet 0/0' 'FastEthernet 1/1' --master "C:\work\\[MASTER]test.xlsx"<br>
--- Physical Port Name renamed --- L3SW1 GigabitEthernet 0/0 -> FastEthernet 1/1<br>

＃python .\network_sketcher.py rename port 'L3SW2' 'Vlan 200' 'Vlan 999' --master "C:\work\\[MASTER]test.xlsx"<br>
--- Virtual Port Name renamed --- L3SW2 Vlan 200 -> Vlan 999<br>


**+AFTER+ <br>**
#python .\network_sketcher.py show l1_interface --master "C:\work\\[MASTER]test.xlsx"<br>
['L3SW1', 'FE 1/1', 'FastEthernet 1/1', 'Auto', 'Auto', '1000BASE-T']<br>
['L3SW2', 'GE 0/0', 'GigabitEthernet 0/0', 'Auto', 'Auto', '1000BASE-T']<br>

#python .\network_sketcher.py show l2_interface --master "C:\work\\[MASTER]test.xlsx"<br>
['L3SW1', '', 'Vlan 201', 'Vlan100', '']<br>
['L3SW1', '', 'Vlan 200', 'Vlan200', '']<br>
['L3SW1', '', 'Vlan 300', 'Vlan300', '']<br>
['L3SW1', 'FastEthernet 1/1', '', 'Vlan100,Vlan200,Vlan300', '']<br>
['L3SW2', '', 'addvlan 999', '', '']<br>
['L3SW2', '', 'Vlan 201', 'Vlan100', '']<br>
['L3SW2', '', 'Vlan 999', 'Vlan200', '']<br>
['L3SW2', '', 'Vlan 202', 'Vlan300', '']<br>
['L3SW2', 'GigabitEthernet 0/0', '', 'Vlan100,Vlan200,Vlan300', '']<br>

#python .\network_sketcher.py show l3_interface --master "C:\work\\[MASTER]test.xlsx"<br>
['L3SW1', 'Vlan 201', '', '']<br>
['L3SW1', 'Vlan 200', '', '']<br>
['L3SW1', 'Vlan 300', '', '']<br>
['L3SW2', 'Vlan 201', '', '']<br>
['L3SW2', 'Vlan 999', '', '']<br>
['L3SW2', 'Vlan 202', '', '']<br>
['L3SW2', 'addvlan 999', '', '']<br>


'''
Export Commands reference
'''

**Be sure to back up the Master file before execution, as you will be editing the Master file directly.**

## What This Procedure Enables

You can execute the following export commands from the CLI:

[export ai_context_file](https://github.com/cisco-open/network-sketcher/wiki/8%E2%80%905.-Export-Commands#export-ai_context_file)<br>
[export device_file](https://github.com/cisco-open/network-sketcher/wiki/8%E2%80%905.-Export-Commands#export-device_file)<br>
[export master_file_backup](https://github.com/cisco-open/network-sketcher/wiki/8%E2%80%905.-Export-Commands#export-master_file_backup)<br>
[export master_file_nodata](https://github.com/cisco-open/network-sketcher/wiki/8%E2%80%905.-Export-Commands#export-master_file_nodata)<br>

## Basic Syntax
```bash
python [file path]/network_sketcher.py [command] --master [master file path]
```
* The positions of [command] and --master [master file path] can be modified as follows:
python [file path]/network_sketcher.py -master [master file path] [command]


## export ai_context_file

Generates a context file for uploading to large language models (LLMs). Outputs network configuration information in text format for use in AI analysis and document generation.
⚠️ Security Warning: The AI context file exported by this command contains data from the master file, including all network (NW) configuration information. Please be aware that uploading this exported file to a large language model (LLM) carries a risk of data leakage.

 ```bash
python [file path]/network_sketcher.py export ai_context_file --master [master file path] --accept-security-risk

 ```

Options:

--accept-security-risk : Explicitly acknowledges the security risk and authorizes the export. Omitting this option will prompt a YES/NO confirmation screen for security risk consent.

* ex.<br>

+Export ai_context_file+

#python .\network_sketcher.py export ai_context_file --master “C:\work\[MASTER]test.xlsx”　--accept-security-risk

--- export_ai_context_file ---<br>
** Exporting xx/xx<br>
--- AI Context file created successfully ---<br>
AI Context file: C:\work\[AI_Context]test.txt<br>
  Size: 47,201 bytes<br>

[Tips]

* The output filename will automatically be [AI_Context]master_file_name.txt


## export device_file

Exports the [DEVICE] file.

```bash
python [file path]/network_sketcher.py export device_file --master [master file path]
```

* ex.<br>

+Export device_file+

#python .\network_sketcher.py export device_file ‘SW-1’ --master “C:\work\[MASTER]test.xlsx”<br>
--- Device file create ---<br>
--- Device file created successfully ---<br>

[Tips]

* The output filename will automatically be [DEVICE]master_file_name.xlsx


## export master_file_backup

Creates a backup of the current Master file. A backup file with a timestamp will be generated.

 ```bash
python [file path]/network_sketcher.py export master_file_backup --master [master file path]
 ```

* ex.<br>

+Export master_file_backup+

#python .\network_sketcher.py export master_file_backup --master “C:\work\[MASTER]test.xlsx”<br>
--- Backup Master file --- C:\work\[MASTER]test_20251208145631.xlsx<br>
--- Master file backup created successfully ---<br>
Original file: C:\work\[MASTER]test.xlsx<br>
  Size: 7,200 bytes<br>
Backup file: C:\work\[MASTER]test_20251208145631.xlsx<br>
  Size: 7,200 bytes<br>
Verification: File sizes match ✓<br>

[Tips]

* Backup filenames are automatically generated as master_file_name_YYYYMMDDHHMMSS.xlsx
* Creating a backup before making changes is recommended
* Backup files are created in the same directory as the original Master file


## export master_file_nodata

Creates an empty Master file template with no data. This can be used as a base file when creating a new network configuration from scratch.

```bash
python [file path]/network_sketcher.py export master_file_nodata --master [master file path]
```

* ex.<br>

+Export master_file_nodata+

#python .\network_sketcher.py export master_file_nodata --master “C:\work\[MASTER]test.xlsx”<br>
--- Empty master file created successfully ---<br>
File: C:\work\[MASTER]test.xlsx<br>
Size: 7,145 bytes<br>
Sheets: Master_Data, Master_Data_L2, Master_Data_L3<br>
The file contains no areas or devices.<br>

[Tips]

* If the file specified with --master already exists, an error occurs and processing terminates.







================================================================================
CRITICAL NETWORK SKETCHER ARCHITECTURE CONSTRAINTS
================================================================================
MANDATORY ARCHITECTURAL RULES - MUST BE FOLLOWED WITHOUT EXCEPTION

================================================================================
SECTION 1: FUNDAMENTAL ARCHITECTURE RULES (RULES 0-7)
================================================================================

--------------------------------------------------------------------------------
RULE 0: NETWORK DIAGRAM LAYOUT PRESERVATION POLICY
--------------------------------------------------------------------------------

CRITICAL LAYOUT RULE:
When analyzing network diagrams, preserve the visual device placement as
closely as possible.

VISUAL LAYOUT ANALYSIS PRIORITY:
1. Identify Central/Hub Devices: Place at center or top of grid
2. Identify Edge/Leaf Devices: Distribute around central device(s)
3. Preserve Left-Right Grouping: LEFT devices -> LEFT columns, RIGHT -> RIGHT
4. Preserve Vertical Relationships: ABOVE -> UPPER rows, BELOW -> LOWER rows

GRID LAYOUT CONSTRUCTION GUIDELINES:

CORRECT Layout Approach:
  Diagram showing:
          [SP]           (Center/Top)
         /    \
     [CX-A] [CX-B]       (Left side, below SP)
     [CY-A] [CY-B]       (Right side, below SP)

  Network Sketcher grid:
  ['ServiceProvider_DC',[
    ['_AIR_','_AIR_','SP','_AIR_','_AIR_'],
    ['CX-A','CX-B','_AIR_','CY-A','CY-B']
  ]]

  Key principles:
  - SP in CENTER COLUMN (position 3 of 5) at TOP ROW
  - CX-A, CX-B on LEFT (positions 1-2) in BOTTOM ROW
  - CY-A, CY-B on RIGHT (positions 4-5) in BOTTOM ROW
  - Use _AIR_ for spacing that reflects diagram layout

INCORRECT Layout:
  ['ServiceProvider_DC',[
    ['CX-A','SP','CY-A'],
    ['CX-B','_AIR_','CY-B']
  ]]
  Problem: Too compact, doesn't reflect spacing, SP not centered

COMMON DIAGRAM PATTERNS:
- Pattern 1 (Star Topology): [['_AIR_','Hub','_AIR_'],['Dev1','Dev2','Dev3','Dev4']]
- Pattern 2 (Horizontal): [['A','B','C','D']]
- Pattern 3 (Vertical): [['A'],['B'],['C']]
- Pattern 4 (Service Provider): [['_AIR_','_AIR_','SP','_AIR_','_AIR_'],['CX-A','CX-B','_AIR_','CY-A','CY-B']]

LAYOUT DECISION RULES:
1. Count Visual Layers: Diagram layers -> Grid rows
2. Count Horizontal Positions: Side-by-side devices/groups -> Grid columns
3. Identify Symmetry: Symmetric diagrams -> Symmetric grid layouts
4. Preserve Empty Space: Use _AIR_ for logical grouping

VERIFICATION OF LAYOUT ACCURACY:
After generating layout commands, verify ALL of the following:
1. Does grid TOP match diagram TOP?
2. Does grid CENTER align with diagram CENTER?
3. Are LEFT devices in grid LEFT columns?
4. Are RIGHT devices in grid RIGHT columns?
5. Does spacing/symmetry match diagram?
6. Are logical groups visually separated in grid?
If ANY answer is NO, revise the grid layout.

--------------------------------------------------------------------------------
RULE 1: PHYSICAL TOPOLOGY VS LOGICAL SEGMENTATION
--------------------------------------------------------------------------------

Network Sketcher distinguishes between PHYSICAL and LOGICAL:

PHYSICAL TOPOLOGY (Areas and Devices):
- Areas = PHYSICAL locations or network segments
- Devices = PHYSICAL equipment (routers, switches, firewalls)
- Layer 1 (L1) links = PHYSICAL cables/connections between devices
- Areas CANNOT be directly connected - only devices within areas can connect
- Device placement within areas should reflect diagram layout

LOGICAL SEGMENTATION (VRFs, VLANs, L3 Instances):
- VRFs = L3 instances (rename l3_instance command)
- VLANs = L2 segments (add l2_segment command)
- Logical segmentation does NOT require separate physical areas
- Logical grouping reflected in device grid layout using spacing

--------------------------------------------------------------------------------
RULE 2: VRF IMPLEMENTATION ARCHITECTURE
--------------------------------------------------------------------------------

When implementing VRF configurations:

CORRECT APPROACH:
1. Create ONE area containing ALL physical devices
2. Place ALL routers/devices in that single area
3. PRESERVE diagram layout when positioning devices in grid
4. Create physical L1 links between devices
5. Assign interfaces to VRFs using rename l3_instance command
6. VRFs exist as logical separation, NOT as separate areas

Example Structure:
- Area: "ServiceProvider"
- Devices: SP (router), CX-A, CX-B, CY-A, CY-B
- Grid: [['_AIR_','_AIR_','SP','_AIR_','_AIR_'],['CX-A','CX-B','_AIR_','CY-A','CY-B']]
- L1 Links: Physical connections between all devices
- L3 Instances (VRFs): CUST-X, CUST-Y (assigned to specific interfaces)

INCORRECT APPROACH:
1. Creating separate areas for each VRF
2. Placing customer devices in separate areas
3. Attempting to connect areas instead of devices
4. Ignoring diagram layout and compressing devices without spacing

WHY THIS MATTERS:
- Areas = PHYSICAL separation (buildings, data centers, locations)
- VRFs = LOGICAL separation (routing tables, customer isolation)
- Grid layout should reflect VISUAL diagram structure

--------------------------------------------------------------------------------
RULE 3: AREA CONNECTION CONSTRAINTS AND WAYPOINT REQUIREMENTS
--------------------------------------------------------------------------------

CRITICAL INTER-AREA CONNECTION RULE:
Devices in different areas CANNOT connect directly to each other.
ALL inter-area connections MUST go through Waypoint area (area name ending _wp_).

CONNECTION ARCHITECTURE:
Area A          Waypoint Area         Area B
[Device-A] <---> [Waypoint] <---> [Device-B]
   (L1)            (_wp_)           (L1)

VALID CONNECTION PATTERNS:
1. Device-to-Device within SAME area: Direct L1 link allowed
2. Device-to-Device across DIFFERENT areas: Must use Waypoint
3. Device-to-Waypoint: Device in standard area -> Waypoint in waypoint area

INVALID CONNECTION PATTERNS:
1. Direct Device-to-Device across different areas without waypoint
2. Area-to-Area direct connection (areas are logical containers)
3. Mixed waypoint types (WAN waypoint for building backbone, or vice versa)

WAYPOINT AREA REQUIREMENTS:
Waypoint areas (_wp_) are MANDATORY when:
1. Connecting devices in different physical areas
2. Representing WAN connections (Internet, MPLS, leased lines)
3. Representing external networks or cloud services
4. Connecting geographically separated sites
5. Representing building backbone/riser connections (MDF-IDF when required)

WAYPOINT NAMING CONVENTION:
CORRECT:
- WAN/Inter-Site: WAN_wp_, Internet_wp_, MPLS_wp_, Cloud_wp_, ISP_Connection_wp_
- Building Backbone: Building1_Backbone_wp_, HQ_Backbone_wp_, Campus_Riser_wp_

INCORRECT:
- VLAN100_wp_, VRF-A_wp_ (logical separation, not physical)
- Floor2_wp_ (may not need waypoint unless mandated)

WAYPOINT USAGE EXAMPLES:
CORRECT: HQ and Branch via MPLS
  [HQ Area] <-> [MPLS_wp_ Area] <-> [Branch Area]

INCORRECT: VRF implementation
  WRONG: [CUST-X Area] <-> [ServiceProvider_wp_] <-> [CUST-Y Area]
  CORRECT: Single area with VRF L3 instances (see Rule 2)

MULTIPLE AREA CONNECTION EXAMPLE:
Scenario: Connect 3 sites (HQ, Branch1, Branch2) via MPLS
python "script" add area_location "[['HQ'],['MPLS_wp_'],['Branch1','Branch2']]" --master "file"
python "script" add device_location "['HQ',[['HQ-Router']]]" --master "file"
python "script" add device_location "['MPLS_wp_',[['MPLS-Core']]]" --master "file"
python "script" add device_location "['Branch1',[['Branch1-Router']]]" --master "file"
python "script" add device_location "['Branch2',[['Branch2-Router']]]" --master "file"
python "script" add l1_link_bulk "[['HQ-Router','MPLS-Core','GigabitEthernet 0/1','port 0'],['MPLS-Core','Branch1-Router','port 1','GigabitEthernet 0/0'],['MPLS-Core','Branch2-Router','port 2','GigabitEthernet 0/0']]" --master "file"

--------------------------------------------------------------------------------
RULE 4: AREA VS WAYPOINT DECISION MATRIX
--------------------------------------------------------------------------------

QUESTION 1: Is this logical or physical separation?
LOGICAL (VRF, VLAN, security zones):
  - Use: Single area with all devices
  - Implement: VRF via L3 instances, VLAN via L2 segments
  - Layout: Preserve diagram positioning with _AIR_ for spacing
  - Do NOT use: Multiple areas or waypoints
PHYSICAL (different buildings, cities, sites):
  - Continue to Question 2

QUESTION 2: Are devices in the same physical location?
SAME LOCATION (same building/data center/floor):
  - Use: Single area containing all devices
  - Connect: Direct L1 links between devices
  - Layout: Match diagram's visual structure
  - Exception: If system mandates waypoint, use Building_Backbone_wp_
DIFFERENT LOCATIONS (different buildings/cities/sites):
  - Use: Multiple areas (one per location)
  - Connect: Via waypoint area representing WAN/connection medium
  - MUST use: Waypoint area for inter-area connections

QUESTION 3: What type of connection between locations?
- WAN: Internet_wp_, MPLS_wp_, VPN_Gateway_wp_
- BUILDING BACKBONE: Building_Backbone_wp_, Campus_Riser_wp_
- DIRECT: Appropriate waypoint for documentation

DECISION MATRIX SUMMARY:
Scenario                     | Areas | Waypoint          | VRF/VLAN    | Layout
-----------------------------|-------|-------------------|-------------|-------------
VRF customers, same DC       | 1     | No                | L3 instance | Match diagram
VLANs on switches            | 1     | No                | L2 segment  | Match diagram
Switches same building       | 1     | No                | No          | Match diagram
Multi-site MPLS/Internet     | 3+    | WAN_wp_           | Optional    | Per-area
Multi-tenant with VRF        | 1     | No                | L3 instance | Match diagram
Campus buildings fiber       | 2-3   | Campus_Backbone   | No          | Per-area
Multi-floor MDF-IDF          | 3+    | Building_Backbone | Optional    | Per-area

--------------------------------------------------------------------------------
RULE 5: COMMON SCENARIOS AND CORRECT IMPLEMENTATION
--------------------------------------------------------------------------------

SCENARIO A: SERVICE PROVIDER WITH VRF CUSTOMERS (SAME DATA CENTER)
Analysis:
- Service provider router (SP) at center/top
- Customer X: CX-A, CX-B (left side)
- Customer Y: CY-A, CY-B (right side)
- VRF CUST-X and CUST-Y (logical separation)
- All in same data center (physical colocation)

CORRECT Implementation:
python "script" add area_location "[['ServiceProvider_DC']]" --master "file"
python "script" add device_location "['ServiceProvider_DC',[['_AIR_','_AIR_','SP','_AIR_','_AIR_'],['CX-A','CX-B','_AIR_','CY-A','CY-B']]]" --master "file"
python "script" add l1_link_bulk "[['CX-A','SP','FastEthernet 0/0','FastEthernet 0/0'],['CX-B','SP','FastEthernet 0/0','FastEthernet 0/1'],['CY-A','SP','FastEthernet 0/0','FastEthernet 1/0'],['CY-B','SP','FastEthernet 0/0','FastEthernet 1/1']]" --master "file"
python "script" rename l3_instance "SP" "FastEthernet 0/0" "CUST-X" --master "file"
python "script" rename l3_instance "SP" "FastEthernet 0/1" "CUST-X" --master "file"
python "script" rename l3_instance "SP" "FastEthernet 1/0" "CUST-Y" --master "file"
python "script" rename l3_instance "SP" "FastEthernet 1/1" "CUST-Y" --master "file"

SCENARIO B: ENTERPRISE HQ AND BRANCH VIA MPLS
python "script" add area_location "[['HQ','MPLS_wp_','Branch']]" --master "file"
python "script" add device_location "['HQ',[['HQ-Core-Router','HQ-Switch']]]" --master "file"
python "script" add device_location "['MPLS_wp_',[['MPLS-Cloud']]]" --master "file"
python "script" add device_location "['Branch',[['Branch-Router','Branch-Switch']]]" --master "file"
python "script" add l1_link_bulk "[['HQ-Core-Router','HQ-Switch','GigabitEthernet 0/1','GigabitEthernet 0/24'],['HQ-Core-Router','MPLS-Cloud','GigabitEthernet 0/0','port 0'],['MPLS-Cloud','Branch-Router','port 1','GigabitEthernet 0/0'],['Branch-Router','Branch-Switch','GigabitEthernet 0/1','GigabitEthernet 0/24']]" --master "file"

SCENARIO C: MULTI-SITE HUB-AND-SPOKE MPLS
python "script" add area_location "[['HQ'],['MPLS_wp_'],['Branch1','Branch2','Branch3']]" --master "file"
python "script" add device_location "['HQ',[['HQ-Router']]]" --master "file"
python "script" add device_location "['MPLS_wp_',[['MPLS-Hub']]]" --master "file"
python "script" add device_location "['Branch1',[['B1-Router']]]" --master "file"
python "script" add device_location "['Branch2',[['B2-Router']]]" --master "file"
python "script" add device_location "['Branch3',[['B3-Router']]]" --master "file"
python "script" add l1_link_bulk "[['HQ-Router','MPLS-Hub','GigabitEthernet 0/0','port 0'],['MPLS-Hub','B1-Router','port 1','GigabitEthernet 0/0'],['MPLS-Hub','B2-Router','port 2','GigabitEthernet 0/0'],['MPLS-Hub','B3-Router','port 3','GigabitEthernet 0/0']]" --master "file"

SCENARIO D: DATA CENTER WITH VRF AND EXTERNAL WAN
python "script" add area_location "[['DataCenter','WAN_wp_']]" --master "file"
python "script" add device_location "['DataCenter',[['Core-Router','Tenant-A-Router','Tenant-B-Router']]]" --master "file"
python "script" add device_location "['WAN_wp_',[['Internet-Gateway']]]" --master "file"
python "script" add l1_link_bulk "[['Core-Router','Tenant-A-Router','GigabitEthernet 0/1','GigabitEthernet 0/0'],['Core-Router','Tenant-B-Router','GigabitEthernet 0/2','GigabitEthernet 0/0']]" --master "file"
python "script" add l1_link "Core-Router" "Internet-Gateway" "GigabitEthernet 0/0" "port 0" --master "file"
python "script" rename l3_instance "Core-Router" "GigabitEthernet 0/1" "Tenant-A" --master "file"
python "script" rename l3_instance "Core-Router" "GigabitEthernet 0/2" "Tenant-B" --master "file"

--------------------------------------------------------------------------------
RULE 6: ERROR DETECTION AND CORRECTION
--------------------------------------------------------------------------------

RED FLAGS INDICATING INCORRECT ARCHITECTURE:
1. VRF names as area names -> Use L3 instances instead
2. Direct inter-area device connections -> Insert waypoint area
3. Customer names as separate areas in VRF -> Use single area + VRF L3 instances
4. Waypoint areas for logical separation -> Use L2/L3 instances instead
5. Multiple areas same building no waypoint -> Consolidate to single area
6. Wrong waypoint type -> Building_Backbone_wp_ (intra), WAN_wp_ (inter-site)
7. Layout doesn't match diagram -> Analyze positioning, use _AIR_ for spacing
8. Multiple L2 segments trunked to L3 physical port -> Convert to L2 port + SVI (see Rule 12)

CORRECTION WORKFLOW:
1. Identify issue from red flags above
2. Determine: Physical or logical separation?
3. If physical: WAN or Building Backbone connection type?
4. Analyze diagram layout: Visual structure?
5. Redesign:
   - Logical -> Single area + L3/L2 instances + layout preservation
   - Physical WAN -> Multiple areas + WAN waypoint + per-area layout
   - Physical Building -> Multiple areas + Building Backbone waypoint + per-area
   - L2/L3 port mismatch -> Convert L3 port to L2 port + SVI (see Rule 12)
6. Regenerate commands
7. Verify with show commands

--------------------------------------------------------------------------------
RULE 7: COMMAND GENERATION DECISION TREE
--------------------------------------------------------------------------------

DECISION FLOW:
Q0: Analyze diagram visual layout (central/hub, edge/leaf, groupings, spacing)
Q1: Different PHYSICAL locations?
  NO -> Q2
  YES -> Q4
Q2: VRFs, VLANs, or logical separation?
  YES -> SOLUTION A (Single area, VRF as L3 instances)
  NO -> Q3
Q3: All devices in same physical space?
  YES -> SOLUTION B (Single area, direct connections)
  NO -> Q4
Q4: How many physical locations?
  2 locations -> Q5
  3+ locations -> Q6
Q5: What connects the two locations?
  WAN -> SOLUTION C (3 areas: Site1, WAN_wp_, Site2)
  Building Backbone -> SOLUTION D (3 areas: MDF, Building_Backbone_wp_, IDF)
Q6: Topology between sites?
  Hub-and-spoke -> SOLUTION E (Hub, Waypoint_wp_, spokes)
  Mesh -> SOLUTION F (Sites, central Waypoint_wp_)
  Multi-floor -> SOLUTION D (MDF, Building_Backbone_wp_, IDFs)

SOLUTION TEMPLATES:
A: Single Area with VRF (1 area, no waypoints, VRF via L3, preserve layout)
B: Single Area Direct (1 area, no waypoints, direct L1 links, preserve layout)
C: Two Sites via WAN (3 areas: Site1, WAN_wp_, Site2, per-area layout)
D: Multi-Floor MDF-IDF (M+2 areas: 1 MDF, 1 Building_Backbone_wp_, M IDFs)
E: Hub-and-Spoke Multi-Site (N+2 areas: Hub, Waypoint_wp_, N spokes)
F: Mesh Network (N+1 areas: N sites, 1 central Waypoint_wp_)

================================================================================
SECTION 2: EXECUTION AND CONFIGURATION RULES (RULES 8-12)
================================================================================

--------------------------------------------------------------------------------
RULE 8: COMMAND EXECUTION SEQUENCE
--------------------------------------------------------------------------------

CRITICAL: Execute commands in correct order to prevent data corruption.
NOTE: All names and addresses in examples are SAMPLES. Replace with actual.

================================================================================
SUBSECTION 8.1: ADD COMMAND EXECUTION SEQUENCE
================================================================================

MANDATORY EXECUTION SEQUENCE FOR ADDING CONFIGURATIONS:

PHASE 1: NETWORK STRUCTURE
1. add area_location (define all areas once)
2. add device_location (batch - PREFERRED) OR add device/add waypoint (incremental)

PHASE 2: PHYSICAL CONNECTIVITY
3. add l1_link_bulk (batch - PREFERRED) OR add l1_link (individual)

PHASE 3: LAYER 2 CONFIGURATION
4. add portchannel (create LAG first)
5. add virtual_port (create SVIs/Loopback)
6. add vport_l1if_direct_binding (subinterfaces)
7. add l2_segment (add VLANs)
8. add vport_l2_direct_binding (VLAN tagging on subinterfaces)

PHASE 4: LAYER 3 CONFIGURATION
9. add ip_address (assign IPs)
10. rename l3_instance (configure VRF - optional)

PHASE 5: MODIFICATIONS (if needed)
11. rename area
12. rename device
13. rename port

PHASE 6: VERIFICATION
14. show commands (verify at each phase)

PHASE EXECUTION RULES:
CORRECT:
- Execute add area_location once with complete structure
- Use add device_location for batch (2+ devices)
- Use add l1_link_bulk for multiple connections (2+ links)
- Complete each phase before moving to next
- Verify after each phase

INCORRECT:
- Mixing add device_location and multiple add device for same area
- Creating links before devices exist
- Adding L2 segments before port-channels
- Skipping verification

KEY COMMAND DEPENDENCIES:
Phase Dependencies:
- Phase 2 requires: Phase 1 complete (devices exist)
- Phase 3 requires: Phase 2 complete (L1 interfaces exist)
- Phase 4 requires: Phase 3 complete (L3 interfaces exist)
- Phase 5: Independent (anytime after object creation)

Critical Dependencies:
- add portchannel -> L1 interface must exist
- add l2_segment -> Interface (physical/virtual) must exist
- add ip_address -> L3 interface must exist
- rename l3_instance -> L3 interface must exist

COMMON DEPLOYMENT SCENARIOS:
Scenario 1 (Simple Office): Phase 1 (1 area, 3 devices), Phase 2 (L1 links), Phase 4 (IPs)
Scenario 2 (Campus VLANs): Phase 1-4 (all phases)
Scenario 3 (Subinterfaces): Phase 1-4 (vport_l1if + vport_l2_direct_binding)
Scenario 4 (VRF): See Rule 5 Scenario A
Scenario 5 (Multi-Site WAN): See Rule 5 Scenario B
Scenario 6 (Port-channel): Phase 1-3 (port-channel MUST be after L1 links)

================================================================================
SUBSECTION 8.2: DELETE COMMAND EXECUTION AND CASCADE BEHAVIOR
================================================================================

CRITICAL CASCADE DELETION RULE:
delete l1_link performs CASCADE DELETION of all associated Layer 2 and Layer 3
configurations automatically. Single command completes all deletions.

--------------------------------------------------------------------------------
8.2.1: CASCADE DELETION MECHANISM
--------------------------------------------------------------------------------

WHAT GETS AUTOMATICALLY DELETED BY delete l1_link:

PHASE 1 (Explicit Deletion):
- Physical link between two devices

PHASE 2 (Automatic Cascade - Layer 2):
- Port-channel membership (if the interface is a member)
- ALL L2 segments (VLANs) configured on the interface
- ALL subinterfaces (virtual ports) bound to the interface
- ALL L2 direct bindings on subinterfaces

PHASE 3 (Automatic Cascade - Layer 3):
- ALL IP addresses on subinterfaces
- ALL IP addresses on the physical interface
- If ALL member interfaces of Port-channel are deleted:
  * The entire Port-channel interface
  * ALL L3 configurations on the Port-channel

--------------------------------------------------------------------------------
8.2.2: CASCADE DELETION EXAMPLES
--------------------------------------------------------------------------------

EXAMPLE 1: BASIC SUBINTERFACE DELETION

Initial Configuration:
  Device: WAN-Dum3
  Interface: GigabitEthernet 0/21
    L1 Link: Connected to Sever-14~1~ GigabitEthernet 0/21
    Subinterface: GigabitEthernet 0/21.100
      L2 Segment: Vlan200
      IP Address: 10.0.1.2/29

CORRECT (Single Command - Cascade Deletion):
python "script" delete l1_link "WAN-Dum3" "GigabitEthernet 0/21" --master "file"

Result - ALL automatically deleted:
- L1 link (WAN-Dum3 <-> Sever-14~1~)
- Subinterface (GigabitEthernet 0/21.100)
- L2 segment (Vlan200) on subinterface
- IP address (10.0.1.2/29) on subinterface

INCORRECT (Manual Multi-Step - UNNECESSARY):
python "script" delete ip_address "WAN-Dum3" "GigabitEthernet 0/21.100" "10.0.1.2/29" --master "file"
python "script" delete vport_l2_direct_binding "WAN-Dum3" "GigabitEthernet 0/21.100" "Vlan200" --master "file"
python "script" delete vport_l1if_direct_binding "WAN-Dum3" "GigabitEthernet 0/21.100" --master "file"
python "script" delete l1_link "WAN-Dum3" "GigabitEthernet 0/21" --master "file"
Reason: Inefficient and redundant - delete l1_link does all automatically

EXAMPLE 2: PORT-CHANNEL CASCADE DELETION

Initial Configuration:
  Device: Access-Stack1
    Interface: TenGigE 1/1/1 (member of Port-channel 1)
      Port-channel: Port-channel 1
      L2 Segments: VLAN10, VLAN100, VLAN200
    Interface: TenGigE 1/1/2 (member of Port-channel 1)
      Port-channel: Port-channel 1
    Port-channel 1 (L3 Interface):
      IP Address: 10.1.10.1/24

Deleting ONE member interface:
python "script" delete l1_link "Access-Stack1" "TenGigE 1/1/1" --master "file"
Result:
- L1 link deleted
- TenGigE 1/1/1 removed from Port-channel 1
- L2 segments removed from TenGigE 1/1/1
- Port-channel 1 STILL EXISTS (TenGigE 1/1/2 still member)
- IP address on Port-channel 1 STILL EXISTS

Deleting ALL member interfaces:
python "script" delete l1_link "Access-Stack1" "TenGigE 1/1/1" --master "file"
python "script" delete l1_link "Access-Stack1" "TenGigE 1/1/2" --master "file"
Result:
- Both L1 links deleted
- TenGigE 1/1/1 and 1/1/2 removed from Port-channel 1
- L2 segments removed from both interfaces
- Port-channel 1 DELETED (no remaining members)
- IP address 10.1.10.1/24 DELETED (Port-channel removed)

--------------------------------------------------------------------------------
8.2.3: VERIFICATION AFTER CASCADE DELETION
--------------------------------------------------------------------------------

VERIFICATION WORKFLOW:
After executing delete l1_link, verify in order:

STEP 1: Verify L1 Link Removal
python "script" show l1_link --master "file" | grep "Device.*Interface"
Expected: Interface not found in L1 link list

STEP 2: Verify L2 Configuration Removal
python "script" show l2_interface --master "file" | grep "Device.*Interface"
Expected: Interface shows empty L2 configuration or baseline state

STEP 3: Verify L3 Configuration Removal
python "script" show l3_interface --master "file" | grep "Device.*Interface"
Expected: Interface not found (if subinterface) or empty configuration

STEP 4: Verify Port-Channel Removal (if applicable)
python "script" show l2_interface --master "file" | grep "Device.*Port-channel"
python "script" show l3_interface --master "file" | grep "Device.*Port-channel"
Expected: Port-channel removed if all member interfaces deleted

CASCADE DELETION VERIFICATION CHECKLIST:
After delete l1_link execution:
- L1 link removed (show l1_link)
- L2 segments removed from interface (show l2_interface)
- Subinterfaces removed (show l2_interface, show l3_interface)
- IP addresses removed from subinterfaces (show l3_interface)
- Port-channel removed if all members deleted (show l2_interface, l3_interface)
- Port-channel membership updated if partial deletion (show l2_interface)

Use with Caution: Single delete l1_link command removes extensive configuration.
Always verify impact before execution.

--------------------------------------------------------------------------------
8.2.4: WHEN TO USE MANUAL DELETION VS CASCADE DELETION
--------------------------------------------------------------------------------

USE delete l1_link (CASCADE DELETION) WHEN:
- Removing physical connection AND ALL associated configurations
- Decommissioning an interface completely
- Removing a link between devices
- Want single command to clean up everything

USE MANUAL DELETION COMMANDS WHEN:
Keeping L1 link but removing specific L2/L3 configurations:
- delete ip_address: Remove specific IP while keeping interface
- delete l2_segment: Remove specific VLAN while keeping others
- delete vport_l2_direct_binding: Remove VLAN from subinterface
- delete vport_l1if_direct_binding: Remove subinterface, keep physical link
- delete portchannel: Remove Port-channel membership, keep L1 link

CASCADE DELETION DECISION MATRIX:
Goal                                  | Command              | Cascade Effect
--------------------------------------|----------------------|------------------
Remove physical link + all configs    | delete l1_link       | Everything deleted
Remove IP only                        | delete ip_address    | No cascade
Remove VLAN only                      | delete l2_segment    | No cascade
Remove subinterface only              | delete vport_l1if... | Removes L2/L3 on subif
Remove Port-channel membership        | delete portchannel   | Removes L2 from port

--------------------------------------------------------------------------------
8.2.5: REAL-WORLD CASCADE DELETION WORKFLOW
--------------------------------------------------------------------------------

SCENARIO: Remove connection between WAN-Dum3 and Sever-14~1~

BEFORE DELETION:
WAN-Dum3 GigabitEthernet 0/21:
  - L1 Link: <-> Sever-14~1~ GigabitEthernet 0/21
  - Subinterface: GigabitEthernet 0/21.100
    - VLAN: Vlan200
    - IP: 10.0.1.2/29

EXECUTION STEPS:

Step 1: Backup Master file
python "script" export master_file_backup --master "file"

Step 2: Single Cascade Deletion Command
python "script" delete l1_link "WAN-Dum3" "GigabitEthernet 0/21" --master "file"

Expected Output:
--- Layer 1 link deleted --- WAN-Dum3 GigabitEthernet 0/21 <-> Sever-14~1~ GigabitEthernet 0/21

AFTER DELETION:
WAN-Dum3 GigabitEthernet 0/21:
  - L1 Link: None (removed)
  - Subinterface: None (removed)
  - VLAN: None (removed)
  - IP: None (removed)

VERIFICATION:

Step 1: Verify L1 link removed
python "script" show l1_link --master "file" | grep "WAN-Dum3.*GigabitEthernet 0/21"
Expected: No output

Step 2: Verify L2 config removed
python "script" show l2_interface --master "file" | grep "WAN-Dum3.*GigabitEthernet 0/21"
Expected: ['WAN-Dum3', 'GigabitEthernet 0/21', '', '', '']

Step 3: Verify L3 config removed
python "script" show l3_interface --master "file" | grep "WAN-Dum3.*GigabitEthernet 0/21"
Expected: No output (subinterface removed)

--------------------------------------------------------------------------------
8.2.6: CASCADE DELETION SUMMARY AND BEST PRACTICES
--------------------------------------------------------------------------------

KEY PRINCIPLES FOR CASCADE DELETION:
1. delete l1_link is PRIMARY deletion method for interfaces
2. Single command removes physical link + ALL dependent configurations
3. Manual deletion commands only needed for selective config removal
4. Always backup before cascade deletion
5. Always verify cascade impact with show commands first
6. Cascade deletion is irreversible without backup

CASCADE DELETION COMMAND PATTERN:
For complete interface removal:
  Step 1: Backup
  Step 2: delete l1_link [device] [interface]
  Step 3: Verify with show l1_link, show l2_interface, show l3_interface

For selective configuration removal:
  Step 1: Backup
  Step 2: Use specific delete command (delete ip_address, delete l2_segment, etc.)
  Step 3: Verify with appropriate show command

CRITICAL WARNINGS:
1. CASCADE DELETION CANNOT BE UNDONE without backup
2. Always check show l1_link FIRST to identify peer device/interface
3. Cascade deletion affects BOTH ends of connection
4. Port-channel cascade occurs only when ALL members deleted
5. Verify impact scope before execution

ERROR PREVENTION FOR DELETION:
DO:
- ALWAYS backup before deletion (export master_file_backup)
- ALWAYS verify what will be deleted (show commands)
- ALWAYS use delete l1_link for complete interface removal
- ALWAYS verify cascade results after deletion

DON'T:
- Delete without backup
- Use manual multi-step deletion for complete interface removal
- Skip verification after deletion
- Assume partial deletion when full cascade occurs

================================================================================
SUBSECTION 8.3: EXECUTION CHECKLISTS
================================================================================

EXECUTION CHECKLIST FOR ADD COMMANDS:

PHASE 1: STRUCTURE
- Backup created (if modifying existing)
- Area structure defined and verified
- All devices placed per area (batch)
- Device placement verified

PHASE 2: CONNECTIVITY
- Physical connections created (batch preferred)
- Connections verified

PHASE 3: LAYER 2
- Port channels created (if needed)
- Virtual ports created (if needed)
- Subinterfaces created (if needed)
- VLANs assigned (if needed)
- Layer 2 verified
- L2/L3 port type mismatch checked (see Rule 12)

PHASE 4: LAYER 3
- IP addresses assigned
- VRF configured (if needed)
- Layer 3 verified
- L3 broadcast domains checked for multiple L2 segments on L3 ports (see Rule 12)

PHASE 5: MODIFICATIONS
- Objects renamed (if needed)
- Renames verified

PHASE 6: FINAL VERIFICATION
- Complete verification done
- Cascade deletion impact verified (if delete l1_link used)
- L2/L3 trunk configuration validated (see Rule 12)
- AI context exported (optional)

EXECUTION CHECKLIST FOR DELETE COMMANDS:

PRE-DELETION:
- Backup created
- Target interface/link identified
- Peer device/interface identified (show l1_link)
- Expected cascade impact assessed
- Verification commands prepared

DELETION:
- Appropriate delete command selected
- Command executed (delete l1_link for complete removal)
- Command output reviewed

POST-DELETION VERIFICATION:
- L1 link removed (show l1_link)
- L2 configurations removed (show l2_interface)
- L3 configurations removed (show l3_interface)
- Port-channel status checked (show l2_interface, show l3_interface)
- Peer device interface status checked
- No unexpected deletions occurred

ERROR PREVENTION RULES (COMPREHENSIVE):
1. ALWAYS use batch operations for 2+ items
2. NEVER mix add device_location and add device for same area
3. ALWAYS complete Phase 1 before Phase 2
4. ALWAYS create port-channels BEFORE adding L2 segments
5. ALWAYS create virtual ports BEFORE assigning IPs
6. ALWAYS verify after each phase
7. ALWAYS backup before modifying existing configs
8. ALWAYS use delete l1_link for complete interface removal (CASCADE)
9. NEVER manually delete L2/L3 before delete l1_link (REDUNDANT)
10. ALWAYS verify cascade deletion impact before execution
11. ALWAYS backup before ANY deletion operation
12. ALWAYS identify peer device/interface before deletion
13. ALWAYS verify cascade results after deletion
14. ALWAYS check for L2/L3 trunk port type mismatch (see Rule 12)

QUICK REFERENCE: COMMAND SELECTION (UPDATED):
Task                       | Number    | Use                    | Alternative
---------------------------|-----------|------------------------|-------------------
Add area structure         | Multiple  | add area_location      | N/A
Place devices in area      | 1 device  | add device             | add device_location
Place devices in area      | 2+ devices| add device_location    | Multiple add device
Create L1 connections      | 1 link    | add l1_link            | add l1_link_bulk
Create L1 connections      | 2+ links  | add l1_link_bulk       | Multiple add l1_link
Remove L1 + all configs    | Per link  | delete l1_link         | Manual (NOT recommended)
Remove device completely   | Per device| delete device          | Manual link deletion
Remove area completely     | Per area  | delete area            | Manual device deletion
Remove IP only             | Per IP    | delete ip_address      | N/A
Remove VLAN only           | Per VLAN  | delete l2_segment      | N/A
Remove subinterface only   | Per subif | delete vport_l1if...   | delete l1_link (cascade)
Remove Port-channel member | Per port  | delete portchannel     | delete l1_link (cascade)
Create port-channel        | Per port  | add portchannel        | N/A
Create virtual interface   | Per if    | add virtual_port       | N/A
Bind subinterface to L1    | Per subif | add vport_l1if_direct_binding | N/A
Add VLAN to interface      | Per VLAN  | add l2_segment         | N/A
Add VLAN to subinterface   | Per VLAN  | add vport_l2_direct_binding | N/A
Assign IP address          | Per IP    | add ip_address         | N/A
Configure VRF              | Per if    | rename l3_instance     | N/A

================================================================================
SUBSECTION 8.4: FINAL VERIFICATION CHECKLIST (UPDATED)
================================================================================

Before generating commands, verify:

ARCHITECTURE (Rules 0-7):
- VRF names are L3 instances, NOT area names
- VLAN names are L2 segments, NOT area names
- Physical locations are separate areas
- Inter-area connections have waypoint area (_wp_)
- Grid layout matches diagram's visual structure
- Central/hub devices in center columns
- _AIR_ used for spacing and symmetry
- Vertical relationships match diagram
- WAN waypoints for inter-site
- Building Backbone waypoints for intra-building MDF-IDF

VIRTUALIZED DEVICES (Rule 9):
- Device name includes member IDs and technology tag
- Interfaces numbered by member (1/0/x, 2/0/x)
- Port-channels include interfaces from multiple members
- VLANs/SVIs configured once (not per member)

PORT-CHANNEL CONFIGURATION (Rule 10):
- Port-channels created on both ends
- Same VLANs configured on both Port-channel interfaces
- VLAN list matches on Device A and B Port-channels
- Trunk configuration symmetric
- VLAN symmetry verified with show l2_interface

IP ADDRESSING (Rule 11):
- All IPv4 octets within valid range (0-255)
- VLAN <= 255: Option 1 or Option 3
- VLAN > 255: Option 2 or Option 3 mapping
- Addressing scheme selected and documented
- Scheme applied consistently
- No octet exceeds 255
- IP addresses verified with show l3_interface
- Gateway IPs use .1 (recommended)
- No conflicts with network/broadcast addresses

L2/L3 TRUNK PORT TYPE VALIDATION (Rule 12):
- No multiple L2 segments trunked to L3 physical port
- Single L2 segment trunk to L3 port is allowed
- Multiple L2 segments require L2 port + SVI configuration
- L3 broadcast domain checked for port type mismatches
- Peer device port type verified for compatibility

CASCADE DELETION (when using delete l1_link):
- Understand delete l1_link removes ALL associated L2/L3 configs
- Backup created before deletion
- Impact verified with show commands (what will be deleted)
- Peer device/interface identified
- Verification planned after deletion (show commands)
- Manual deletion commands NOT used before delete l1_link
- Single delete l1_link command used instead of multi-step manual deletion
- Cascade deletion results verified after execution

--------------------------------------------------------------------------------
RULE 9: VIRTUALIZED MULTI-CHASSIS DEVICE NAMING CONVENTION
--------------------------------------------------------------------------------

PURPOSE:
When multiple physical hardware units operate as single logical device
(StackWise, StackWise Virtual, VSS, vPC, MC-LAG), represent as unified device.

NAMING CONVENTION STANDARD:
CORRECT Format: [DeviceName]-[Member1ID]-[Member2ID]...(Technology)

Examples:
- Dist-SW1-2(StackVirtual) - Two distribution switches
- Access-SW1-2-3-4(Stack) - Four access switches
- Core-SW1-2(VSS) - Two core switches (legacy)
- Nexus-SW1-2(vPC) - Two Nexus switches
- AGG-SW1-2-3(Stack) - Three aggregation switches

Format Components:
1. Base Name: Functional role (Dist-SW, Access-SW, Core-SW)
2. Member IDs: Hyphen-separated (1-2, 1-2-3-4)
3. Technology Tag: (Stack, StackVirtual, VSS, vPC, MC-LAG)

INCORRECT:
Dist-SW1 and Dist-SW2 as separate, DistributionStack, Dist-SW-Pair,
Dist-SW1-2 without tag

SUPPORTED VIRTUALIZATION TECHNOLOGIES:
Technology              | Naming Tag      | Example
------------------------|-----------------|------------------------
StackWise (up to 8)     | (Stack)         | Access-SW1-2-3-4(Stack)
StackWise Virtual (2)   | (StackVirtual)  | Dist-SW1-2(StackVirtual)
VSS (2, legacy)         | (VSS)           | Core-SW1-2(VSS)
vPC (Nexus)             | (vPC)           | Nexus-SW1-2(vPC)
MC-LAG                  | (MC-LAG)        | AGG-SW1-2(MC-LAG)

INTERFACE NAMING CONVENTION:
2-member systems (StackVirtual, vPC, VSS):
- Member 1: GigabitEthernet 1/0/x, TenGigabitEthernet 1/0/x
- Member 2: GigabitEthernet 2/0/x, TenGigabitEthernet 2/0/x

Multi-member stacks (StackWise):
- Member 1: GigabitEthernet 1/0/x
- Member 2: GigabitEthernet 2/0/x
- Member N: GigabitEthernet N/0/x

PORT-CHANNEL CONFIGURATION:
CORRECT Approach:
1. Create L1 links to BOTH members
2. Add port-channel to remote device's interfaces
3. Add port-channel to virtualized device's interfaces (one per member)
4. Result: Redundant, load-balanced MEC/cross-stack connection

Example:
python "script" add l1_link_bulk "[['Access-Stack1','Dist-SW1-2(StackVirtual)','TenGigE 1/1/1','GigabitEthernet 1/0/11'],['Access-Stack1','Dist-SW1-2(StackVirtual)','TenGigE 1/1/2','GigabitEthernet 2/0/11']]" --master "file"
python "script" add portchannel "Access-Stack1" "TenGigE 1/1/1" "Port-channel 1" --master "file"
python "script" add portchannel "Access-Stack1" "TenGigE 1/1/2" "Port-channel 1" --master "file"
python "script" add portchannel "Dist-SW1-2(StackVirtual)" "GigabitEthernet 1/0/11" "Port-channel 11" --master "file"
python "script" add portchannel "Dist-SW1-2(StackVirtual)" "GigabitEthernet 2/0/11" "Port-channel 11" --master "file"

HIGH AVAILABILITY DESIGN PATTERNS:
Pattern 1 (Dual-Homed): [SW1] Po1 <-> [Dist-SW1-2(StackVirtual)] Po11 (Gi1/0/11 + Gi2/0/11)
Pattern 2 (Stack to StackVirtual): [Access-SW1-2-3-4(Stack)] Po1 <-> [Dist-SW1-2(StackVirtual)] Po11
Pattern 3 (Multiple Stacks): Multiple Access-Stack to single Dist-SW1-2(StackVirtual) with Po11-14

CONFIGURATION REQUIREMENTS:
Mandatory Elements:
1. Device Name: [Name]-[Members](Technology)
2. Interface Naming: Member-specific (1/0/x, 2/0/x, N/0/x)
3. Port-Channel: One interface per member
4. VLAN/SVI: Configured once on logical device

BEST PRACTICES:
DO:
- Use technology tag in device name
- Use member-specific interface numbering
- Create port-channels with one interface per member
- Configure VLANs/SVIs once on logical device

DON'T:
- Represent as separate physical devices
- Omit technology tag
- Use identical interface numbers for different members
- Duplicate VLAN/SVI configuration

VERIFICATION:
After configuration:
1. Device name includes member IDs and technology tag
2. Interfaces numbered by member (1/0/x, 2/0/x)
3. Port-channels include interfaces from multiple members
4. L1 links connect to different member interfaces
5. VLANs/SVIs configured once (not per member)
6. IP addresses assigned once to logical interface

--------------------------------------------------------------------------------
RULE 10: PORT-CHANNEL VLAN SYMMETRY RULE
--------------------------------------------------------------------------------

CRITICAL: Port-channels connecting two devices MUST have identical VLAN
configuration on BOTH ends.

CORE PRINCIPLE:
BOTH Port-channel interfaces must carry the SAME VLANs

WHY THIS MATTERS:
Technical Reasons:
1. Port-channel is trunk link carrying multiple VLANs
2. Asymmetric VLAN causes: Traffic black-holing, VLAN inconsistency errors,
   Spanning-tree issues, Forwarding failures

Design Intent:
- If VLAN 100 needs to traverse Access to Distribution
- VLAN 100 must exist on Port-channel at BOTH Access AND Distribution layers

CONFIGURATION WORKFLOW:
Step 1: Create Port-channels on both devices
Step 2: Add VLANs to BOTH Port-channels (symmetric configuration)
Step 3: Verify symmetry

Example:
python "script" add portchannel "Access-Stack1" "TenGigE 1/1/1" "Port-channel 1" --master "file"
python "script" add portchannel "Access-Stack1" "TenGigE 1/1/2" "Port-channel 1" --master "file"
python "script" add portchannel "Dist-SW1-2(StackVirtual)" "GigabitEthernet 1/0/11" "Port-channel 11" --master "file"
python "script" add portchannel "Dist-SW1-2(StackVirtual)" "GigabitEthernet 2/0/11" "Port-channel 11" --master "file"

python "script" add l2_segment "Access-Stack1" "Port-channel 1" "VLAN10" --master "file"
python "script" add l2_segment "Access-Stack1" "Port-channel 1" "VLAN100" --master "file"
python "script" add l2_segment "Access-Stack1" "Port-channel 1" "VLAN200" --master "file"
python "script" add l2_segment "Dist-SW1-2(StackVirtual)" "Port-channel 11" "VLAN10" --master "file"
python "script" add l2_segment "Dist-SW1-2(StackVirtual)" "Port-channel 11" "VLAN100" --master "file"
python "script" add l2_segment "Dist-SW1-2(StackVirtual)" "Port-channel 11" "VLAN200" --master "file"

python "script" show l2_interface --master "file"

COMMON MISTAKES:
Mistake 1: VLANs only on one side
Mistake 2: Different VLANs on each side
Mistake 3: Adding VLANs only to physical interfaces

CORRECT: VLANs added to Port-channel interface (logical aggregation),
         SAME VLANs on BOTH ends

PORT-CHANNEL VLAN SYMMETRY CHECKLIST:
Device A:
- Port-channel created
- Physical interfaces added to Port-channel
- VLAN list identified
- ALL VLANs added to Device A's Port-channel

Device B:
- Port-channel created
- Physical interfaces added to Port-channel
- SAME VLAN list
- ALL SAME VLANs added to Device B's Port-channel

Verification:
- show l2_interface shows symmetric VLAN lists
- VLAN lists match exactly on both Port-channels
- No missing VLANs on either side

KEY PRINCIPLES:
1. Port-channel = Logical trunk interface
2. VLANs on Port-channel must be symmetric
3. Configure VLANs on Port-channel, not on physical member interfaces
4. Same VLAN list on both ends of connection
5. Verify symmetry before moving to next phase

QUICK MNEMONIC: "Two devices, one link, same VLANs"

COMMAND PATTERN:
For each Port-channel connection:
1. Create Port-channel on Device A
2. Create Port-channel on Device B
3. Add VLAN-X to Device A Port-channel
4. Add VLAN-X to Device B Port-channel (IMMEDIATELY AFTER step 3)
5. Repeat steps 3-4 for all required VLANs
6. Verify symmetry

--------------------------------------------------------------------------------
RULE 11: VALID IPV4 ADDRESS RANGE CONSTRAINTS
--------------------------------------------------------------------------------

QUICK DECISION GUIDE:
1. Is VLAN ID <= 255?
   YES -> Option 1 (10.1.VLAN.1/24) or Option 3 for consistency
   NO -> Q2
2. Is VLAN ID <= 2550?
   YES -> Option 3: 10.1.(VLAN/10).1/24
   NO -> Option 2: 10.(VLAN/100).(VLAN%100).1/24
3. Execute validation before command generation

EXAMPLE QUICK REFERENCE:
- VLAN 10 -> 10.1.1.1/24 (Option 3: 10/10=1)
- VLAN 100 -> 10.1.10.1/24 (Option 3: 100/10=10)
- VLAN 300 -> 10.1.30.1/24 (Option 3: 300/10=30)
- VLAN 3000 -> 10.30.0.1/24 (Option 2: 3000/100=30, 3000%100=0)

IPV4 ADDRESS FORMAT VALIDATION:
CRITICAL: All IPv4 addresses must comply with valid octet ranges (0-255).
Valid Format: X.X.X.X/subnet_mask (each octet 0 <= value <= 255)
Example: 10.1.100.1/24 VALID
Invalid: 10.1.300.1/24 INVALID (300 > 255)

COMMON MISTAKES:
INCORRECT:
1. Using VLAN ID directly as third octet when VLAN > 255
   VLAN 300 -> 10.1.300.1/24 INVALID
2. Using sequential numbering without validation
   192.168.256.1/24 INVALID (256 > 255)

CORRECT:
1. Map large VLAN IDs to valid IP ranges
   VLAN 300 -> 10.3.0.1/24 (Option 2) or 10.1.30.1/24 (Option 3)
2. Use simple sequential mapping
   VLAN 300 -> 10.1.30.1/24

RECOMMENDED IP ADDRESSING SCHEMES:
Option 1 (VLAN <= 255): 10.1.VLAN.0/24 (Gateway: 10.1.VLAN.1)
  VLAN 10 -> 10.1.10.0/24 (Gateway: 10.1.10.1)
  VLAN 100 -> 10.1.100.0/24 (Gateway: 10.1.100.1)

Option 2 (VLAN > 255): 10.FLOOR(VLAN/100).VLAN%100.0/24
  VLAN 300 -> 10.3.0.0/24 (Gateway: 10.3.0.1)
  VLAN 999 -> 10.9.99.0/24 (Gateway: 10.9.99.1)

Option 3 (RECOMMENDED DEFAULT): 10.1.(VLAN/10).0/24 - Works for VLANs 1-2550
  VLAN 10 -> 10.1.1.0/24 (Gateway: 10.1.1.1)
  VLAN 100 -> 10.1.10.0/24 (Gateway: 10.1.10.1)
  VLAN 300 -> 10.1.30.0/24 (Gateway: 10.1.30.1)
  VLAN 999 -> 10.1.99.0/24 (Gateway: 10.1.99.1)

RECOMMENDED DEFAULT SCHEME:
Primary: Option 3 (Simple Compression) - VLANs 1-2550
Fallback: Option 2 (Divided Mapping) - VLANs 1-4094

Rationale:
- Easy to remember and troubleshoot
- Clear correlation between VLAN and subnet
- Sufficient address space for most deployments
- Mathematically guaranteed to produce valid addresses

VALIDATION LOGIC PSEUDOCODE:
def validate_and_generate_ip(vlan_id, base_network="10.1", scheme="option3"):
    if scheme == "option3":
        third_octet = vlan_id // 10
        if third_octet > 255:
            return validate_and_generate_ip(vlan_id, base_network, "option2")
        ip_address = f"{base_network}.{third_octet}.1/24"
    elif scheme == "option2":
        second_octet = vlan_id // 100
        third_octet = vlan_id % 100
        ip_address = f"10.{second_octet}.{third_octet}.1/24"
    # Final validation
    octets = ip_address.split('/')[0].split('.')
    for i, octet in enumerate(octets):
        if int(octet) < 0 or int(octet) > 255:
            raise ValueError(f"Invalid octet {i+1}")
    return ip_address

MANDATORY PRE-COMMAND VALIDATION:
BEFORE executing any add ip_address command:
Step 1: Parse the IP address
Step 2: Extract each octet
Step 3: Verify each octet <= 255
Step 4: If validation fails:
   - Identify which octet is invalid
   - Apply appropriate mapping scheme
   - Regenerate IP address
   - Re-validate
Step 5: Only execute command after successful validation

EXAMPLE VALIDATION WORKFLOW:
User: "Configure VLAN 300 with gateway"
LLM:
1. Identify VLAN: 300
2. Check scheme: Using Option 3 (default)
3. Calculate: 300 / 10 = 30 (integer division)
4. Generate: 10.1.30.1/24
5. Validate: 10 OK, 1 OK, 30 OK, 1 OK (all <= 255)
6. Output: add ip_address "Device" "Vlan 300" "10.1.30.1/24"

ERROR RECOVERY EXAMPLES:
Error 1: add ip_address "Switch" "Vlan 300" "10.1.300.1/24"
Analysis: Third octet 300 > 255
Fix (Option 3): 10.1.30.1/24 (300 / 10 = 30)
Corrected: add ip_address "Switch" "Vlan 300" "10.1.30.1/24"

Error 2: add ip_address "Router" "Vlan 999" "10.1.999.1/24"
Analysis: Third octet 999 > 255
Fix (Option 3): 10.1.99.1/24 (999 / 10 = 99)
Corrected: add ip_address "Router" "Vlan 999" "10.1.99.1/24"

QUICK REFERENCE CONVERSION TABLE:
VLAN Range  | Scheme              | Example
------------|---------------------|------------------------
1-255       | Option 1 (Direct)   | VLAN 100 -> 10.1.100.1/24
256-999     | Option 3 (/10)      | VLAN 300 -> 10.1.30.1/24
1000-2550   | Option 3 (/10)      | VLAN 1500 -> 10.1.150.1/24
2551-4094   | Option 2 (/100)     | VLAN 3000 -> 10.30.0.1/24

ERROR PREVENTION CHECKLIST:
Before executing add ip_address command:
- All octets in range 0-255
- VLAN-to-IP mapping scheme selected and documented
- No IP address conflicts with existing subnets
- Subnet mask is valid (/8, /16, /24, /30, etc.)
- Gateway IP is within subnet range
- Gateway IP is not network or broadcast address
- Scheme consistently applied across all VLANs

COMMON CAMPUS VLAN NAMING AND IP SCHEME (Option 3):
VLAN | Purpose            | IP Subnet     | Gateway    | Calculation
-----|-------------------|---------------|------------|-------------
1    | Native (unused)   | -             | -          | Reserved
10   | Management        | 10.1.1.0/24   | 10.1.1.1   | 10/10=1
20   | Voice             | 10.1.2.0/24   | 10.1.2.1   | 20/10=2
30   | Video             | 10.1.3.0/24   | 10.1.3.1   | 30/10=3
100  | Employee Data     | 10.1.10.0/24  | 10.1.10.1  | 100/10=10
200  | Guest Wireless    | 10.1.20.0/24  | 10.1.20.1  | 200/10=20
300  | Employee Wireless | 10.1.30.0/24  | 10.1.30.1  | 300/10=30
400  | IoT Devices       | 10.1.40.0/24  | 10.1.40.1  | 400/10=40
500  | Security/Cameras  | 10.1.50.0/24  | 10.1.50.1  | 500/10=50
999  | Quarantine        | 10.1.99.0/24  | 10.1.99.1  | 999/10=99

SUMMARY - KEY TAKEAWAYS:
1. ALWAYS validate IPv4 octets <= 255 before generating commands
2. Use Option 3 (Simple Compression) as default for VLANs 1-2550
3. Automatically fallback to Option 2 for VLANs > 2550
4. Never directly map VLAN ID to IP when VLAN > 255
5. Document addressing scheme for consistency
6. Use integer division for all calculations
7. Verify with show commands after IP assignment

FINAL COMMAND GENERATION RULES:
DO:
- Calculate third octet: VLAN_ID / 10 (Option 3, integer division)
- Validate all octets <= 255 BEFORE command generation
- Use consistent scheme across all VLANs
- Document the mapping logic
- Provide conversion table when generating multiple IPs
- Use .1 for gateway addresses (recommended)

DON'T:
- Use VLAN ID directly as octet when > 255
- Generate commands without validation
- Mix different schemes randomly without documentation
- Assume user will manually fix invalid IPs
- Use floating-point division (always use integer division)

--------------------------------------------------------------------------------
RULE 12: LAYER 2/LAYER 3 TRUNK PORT TYPE COMPATIBILITY
--------------------------------------------------------------------------------

CRITICAL PORT TYPE RULE:
A Layer 2 trunk port carrying MULTIPLE VLANs CANNOT connect directly to a
Layer 3 physical port. This creates an invalid configuration state in Network
Sketcher.

================================================================================
SUBSECTION 12.1: UNDERSTANDING PORT TYPES
================================================================================

LAYER 2 PORT (Switchport):
- Carries Layer 2 frames (Ethernet frames with VLAN tags)
- Can carry multiple VLANs (trunk mode) or single VLAN (access mode)
- Does NOT have IP address assigned to physical interface
- L3 functionality provided by SVIs (Switched Virtual Interfaces)

LAYER 3 PORT (Routed Port):
- Carries Layer 3 packets (IP packets)
- Does NOT carry VLAN tags on physical interface
- HAS IP address assigned directly to physical interface
- Acts as router interface, not switch port

NETWORK SKETCHER REPRESENTATION:
L2 Port: Physical interface with L2 segments in show l2_interface
L3 Port: Physical interface with IP address in show l3_interface

================================================================================
SUBSECTION 12.2: INVALID CONFIGURATION DETECTION
================================================================================

INVALID: MULTIPLE L2 SEGMENTS TRUNKED TO L3 PHYSICAL PORT

Error Condition:
Device A (L2 Port - Trunk with Multiple VLANs) <-> Device B (L3 Port - Routed)

Example (ERROR STATE):
show l2_interface output:
['sw1', 'GigabitEthernet 9/0', '', '100,200', '']  <- L2 port, MULTIPLE VLANs
['sw2', 'GigabitEthernet 9/0', '', '', '']          <- Empty L2 config

show l3_interface output:
['sw1', 'Vlan 100', '', '10.0.0.1/29']              <- SVI on sw1
['sw1', 'Vlan 200', '', '10.0.0.2/29']              <- SVI on sw1
['sw2', 'GigabitEthernet 9/0', '', '10.0.0.3/29']   <- L3 port on PHYSICAL interface

show l3_broadcast_domain output:
[[[1, 2, 3], [['sw1', 'Vlan 100'], ['sw1', 'Vlan 200'], ['sw2', 'GigabitEthernet 9/0']]]]
                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                                                       Problem: Multiple SVIs + L3 port
                                                       in same broadcast domain

WHY THIS IS INVALID:
1. sw1 GigabitEthernet 9/0 is L2 trunk carrying VLAN 100 and VLAN 200
2. sw2 GigabitEthernet 9/0 is L3 routed port (has IP directly on physical)
3. L2 trunk CANNOT connect to L3 routed port
4. Multiple L2 segments (100, 200) from sw1 converge on single L3 port on sw2
5. This creates ambiguous Layer 3 broadcast domain

DETECTION METHOD:
Check show l3_broadcast_domain for:
- Same broadcast domain containing multiple SVIs from one device
- Plus physical L3 port from peer device
- Pattern: [[domain_id, [['DeviceA', 'Vlan X'], ['DeviceA', 'Vlan Y'], ['DeviceB', 'Physical_Port']]]]

VALID: SINGLE L2 SEGMENT TRUNKED TO L3 PHYSICAL PORT (EXCEPTION)

Allowed Condition:
Device A (L2 Port - Trunk with SINGLE VLAN) <-> Device B (L3 Port - Routed)

Example (VALID STATE):
show l2_interface output:
['sw1', 'GigabitEthernet 9/0', '', '100', '']       <- L2 port, SINGLE VLAN only
['sw2', 'GigabitEthernet 9/0', '', '', '']          <- Empty L2 config

show l3_interface output:
['sw1', 'Vlan 100', '', '10.0.0.1/29']              <- SVI on sw1
['sw2', 'GigabitEthernet 9/0', '', '10.0.0.3/29']   <- L3 port on PHYSICAL interface

show l3_broadcast_domain output:
[[[1, 2], [['sw1', 'Vlan 100'], ['sw2', 'GigabitEthernet 9/0']]]]
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                                Valid: Single SVI + L3 port in broadcast domain

WHY THIS IS VALID:
1. sw1 GigabitEthernet 9/0 carries only SINGLE VLAN (100)
2. sw2 GigabitEthernet 9/0 is L3 routed port
3. Single L2 segment creates unambiguous point-to-point L3 connection
4. No conflict in Layer 3 broadcast domain

================================================================================
SUBSECTION 12.3: ERROR CORRECTION PROCEDURE
================================================================================

CORRECTION WORKFLOW FOR MULTIPLE L2 SEGMENTS TO L3 PORT:

SCENARIO: Convert invalid multi-VLAN trunk to L3 port into valid configuration

BEFORE (ERROR STATE):
sw1: L2 trunk with VLAN 100, 200 -> sw2: L3 routed port

CORRECTION STEPS:

Step 1: Identify the error
python "script" show l3_broadcast_domain --master "file"
Look for: Multiple SVIs from one device + Physical L3 port from peer

Step 2: Decide which VLAN to use for trunk
Selection criteria:
- Default VLAN (if applicable)
- Lowest VLAN ID (if no default VLAN)
- Management VLAN (if specified)
- Primary data VLAN (user-specified)

Step 3: Convert L3 physical port to L2 switchport
On Device B (sw2):
a. Remove IP address from physical interface
b. Add L2 segment to physical interface (selected VLAN)
c. Create SVI (Virtual Port) for L3 functionality

Step 4: Execute correction commands
# Remove IP from L3 physical port
python "script" delete ip_address "sw2" "GigabitEthernet 9/0" "10.0.0.3/29" --master "file"

# Add L2 segment to convert to switchport (selecting VLAN 100 - lowest VLAN ID)
python "script" add l2_segment "sw2" "GigabitEthernet 9/0" "100" --master "file"

# Create SVI for L3 functionality
python "script" add virtual_port "sw2" "Vlan 100" --master "file"

# Optionally: Assign IP to SVI if needed
python "script" add ip_address "sw2" "Vlan 100" "10.0.0.3/29" --master "file"

AFTER (CORRECTED STATE):
sw1: L2 trunk with VLAN 100, 200 -> sw2: L2 switchport with VLAN 100 + SVI

show l2_interface output:
['sw1', 'GigabitEthernet 9/0', '', '100,200', '']   <- L2 trunk (multiple VLANs)
['sw2', '', 'Vlan 100', '100', '']                  <- SVI created
['sw2', 'GigabitEthernet 9/0', '', '100', '']       <- L2 switchport (single VLAN)

show l3_interface output:
['sw1', 'Vlan 100', '', '10.0.0.1/29']
['sw1', 'Vlan 200', '', '10.0.0.2/29']
['sw2', 'Vlan 100', '', '10.0.0.3/29']              <- IP on SVI, not physical port

show l3_broadcast_domain output:
[[[1, 3], [['sw1', 'Vlan 100'], ['sw2', 'Vlan 100']]],
 [[2], [['sw1', 'Vlan 200']]]]
Valid: Each broadcast domain has consistent port types

================================================================================
SUBSECTION 12.4: VLAN SELECTION CRITERIA FOR CORRECTION
================================================================================

When correcting multiple L2 segments to L3 port error, select VLAN using:

PRIORITY ORDER:
1. User-specified VLAN (if explicitly mentioned)
2. Default VLAN (VLAN 1) if present in trunk
3. Management VLAN (typically VLAN 10) if present
4. Lowest VLAN ID in the trunk

SELECTION LOGIC:
def select_vlan_for_l3_port_conversion(l2_segment_list):
    """
    Select appropriate VLAN when converting L3 port to L2 port + SVI

    Args:
        l2_segment_list: List of L2 segment names (e.g., ['100', '200'])

    Returns:
        Selected VLAN name for trunk connection
    """
    # Priority 1: Check for Default VLAN
    if 'DefaultVlan' in l2_segment_list or '1' in l2_segment_list:
        return 'DefaultVlan' if 'DefaultVlan' in l2_segment_list else '1'

    # Priority 2: Check for Management VLAN (typically 10)
    if '10' in l2_segment_list:
        return '10'

    # Priority 3: Select lowest VLAN ID
    vlan_ids = [int(v) for v in l2_segment_list if v.isdigit()]
    if vlan_ids:
        return str(min(vlan_ids))

    # Priority 4: First VLAN in list
    return l2_segment_list[0]

EXAMPLE VLAN SELECTION:
Trunk with VLANs: ['100', '200', '300']
  Selected VLAN: 100 (lowest VLAN ID)

Trunk with VLANs: ['DefaultVlan', '100', '200']
  Selected VLAN: DefaultVlan (default VLAN priority)

Trunk with VLANs: ['10', '100', '200']
  Selected VLAN: 10 (management VLAN priority)

================================================================================
SUBSECTION 12.5: ERROR DETECTION WORKFLOW
================================================================================

AUTOMATIC ERROR DETECTION:
When generating commands, check for L2/L3 trunk port type mismatch:

Step 1: Analyze show l1_link output
Identify all connected interface pairs

Step 2: For each connection, check show l2_interface
Extract L2 segment configuration for both ends

Step 3: For each connection, check show l3_interface
Extract L3 configuration for both ends

Step 4: Identify error pattern
If Device A interface has:
- Multiple L2 segments (e.g., '100,200')
AND Device B interface has:
- No L2 segments (empty '')
- IP address on physical interface
THEN: Error detected

Step 5: Apply correction procedure (SUBSECTION 12.3)

ERROR DETECTION EXAMPLE:

Analyzing connection: sw1 GigabitEthernet 9/0 <-> sw2 GigabitEthernet 9/0

show l2_interface check:
sw1 GigabitEthernet 9/0: L2 segments = '100,200' (2 VLANs)
sw2 GigabitEthernet 9/0: L2 segments = '' (none)

show l3_interface check:
sw1 GigabitEthernet 9/0: No IP on physical interface
sw2 GigabitEthernet 9/0: IP = '10.0.0.3/29' (L3 routed port)

Analysis:
- sw1: L2 trunk with MULTIPLE VLANs (100, 200)
- sw2: L3 routed port
- ERROR: Multiple L2 segments trunked to L3 physical port

Correction:
Select VLAN: 100 (lowest VLAN ID)
Convert sw2 GigabitEthernet 9/0 to L2 switchport with VLAN 100
Create sw2 Vlan 100 SVI for L3 functionality

================================================================================
SUBSECTION 12.6: VALID CONFIGURATION PATTERNS
================================================================================

PATTERN 1: L2 TRUNK (MULTIPLE VLANS) TO L2 SWITCHPORT (VALID)
Device A (L2 Port): Multiple VLANs (100, 200, 300)
Device B (L2 Port): Same multiple VLANs (100, 200, 300)
Result: Valid Layer 2 trunk configuration

PATTERN 2: L2 TRUNK (SINGLE VLAN) TO L3 ROUTED PORT (VALID - EXCEPTION)
Device A (L2 Port): Single VLAN (100)
Device B (L3 Port): IP address on physical interface
Result: Valid - Single VLAN creates unambiguous point-to-point

PATTERN 3: L3 ROUTED PORT TO L3 ROUTED PORT (VALID)
Device A (L3 Port): IP address on physical interface
Device B (L3 Port): IP address on physical interface
Result: Valid point-to-point Layer 3 connection

PATTERN 4: L2 TRUNK (MULTIPLE VLANS) TO L2 SWITCHPORT WITH SVI (VALID)
Device A (L2 Port): Multiple VLANs (100, 200, 300)
Device B (L2 Port): Multiple VLANs (100, 200, 300) + SVIs for L3
Result: Valid Layer 2 trunk with Layer 3 gateway on Device B

PATTERN 5 (INVALID): L2 TRUNK (MULTIPLE VLANS) TO L3 ROUTED PORT
Device A (L2 Port): Multiple VLANs (100, 200, 300)
Device B (L3 Port): IP address on physical interface
Result: INVALID - Must convert to Pattern 4

================================================================================
SUBSECTION 12.7: CORRECTION COMMAND EXAMPLES
================================================================================

EXAMPLE 1: CORRECTING MULTIPLE VLAN TRUNK TO L3 PORT

BEFORE (ERROR):
sw1 GigabitEthernet 9/0: L2 trunk with VLAN 100, 200
sw2 GigabitEthernet 9/0: L3 routed port with IP 10.0.0.3/29

Detection:
python "script" show l2_interface --master "file"
['sw1', 'GigabitEthernet 9/0', '', '100,200', '']
['sw2', 'GigabitEthernet 9/0', '', '', '']

python "script" show l3_interface --master "file"
['sw2', 'GigabitEthernet 9/0', '', '10.0.0.3/29']

Correction Commands:
# Step 1: Remove IP from physical interface
python "script" delete ip_address "sw2" "GigabitEthernet 9/0" "10.0.0.3/29" --master "file"

# Step 2: Convert to L2 switchport (select VLAN 100 - lowest VLAN ID)
python "script" add l2_segment "sw2" "GigabitEthernet 9/0" "100" --master "file"

# Step 3: Create SVI for L3 functionality
python "script" add virtual_port "sw2" "Vlan 100" --master "file"

# Step 4 (Optional): Assign IP to SVI if needed
python "script" add ip_address "sw2" "Vlan 100" "10.0.0.3/29" --master "file"

AFTER (CORRECTED):
sw1 GigabitEthernet 9/0: L2 trunk with VLAN 100, 200
sw2 GigabitEthernet 9/0: L2 switchport with VLAN 100
sw2 Vlan 100: SVI with IP 10.0.0.3/29

Verification:
python "script" show l2_interface --master "file"
['sw1', 'GigabitEthernet 9/0', '', '100,200', '']
['sw2', '', 'Vlan 100', '100', '']
['sw2', 'GigabitEthernet 9/0', '', '100', '']

python "script" show l3_interface --master "file"
['sw1', 'Vlan 100', '', '10.0.0.1/29']
['sw1', 'Vlan 200', '', '10.0.0.2/29']
['sw2', 'Vlan 100', '', '10.0.0.3/29']

EXAMPLE 2: VALID SINGLE VLAN TRUNK TO L3 PORT (NO CORRECTION NEEDED)

Configuration:
sw1 GigabitEthernet 9/0: L2 trunk with VLAN 100 ONLY
sw2 GigabitEthernet 9/0: L3 routed port with IP 10.0.0.3/29

Detection:
python "script" show l2_interface --master "file"
['sw1', 'GigabitEthernet 9/0', '', '100', '']       <- SINGLE VLAN only
['sw2', 'GigabitEthernet 9/0', '', '', '']

python "script" show l3_interface --master "file"
['sw1', 'Vlan 100', '', '10.0.0.1/29']
['sw2', 'GigabitEthernet 9/0', '', '10.0.0.3/29']

Analysis: VALID - Single VLAN trunk to L3 port is allowed (exception)
Action: No correction needed

================================================================================
SUBSECTION 12.8: VALIDATION CHECKLIST FOR L2/L3 TRUNK COMPATIBILITY
================================================================================

VALIDATION WORKFLOW:
For each L1 link in the network:

Step 1: Extract L2 configuration for both interfaces
Device A L2 segments: [list of VLANs]
Device B L2 segments: [list of VLANs]

Step 2: Extract L3 configuration for both interfaces
Device A L3 config: IP on physical? SVI?
Device B L3 config: IP on physical? SVI?

Step 3: Count L2 segments on each side
Device A VLAN count: N
Device B VLAN count: M

Step 4: Apply validation rules
IF (N > 1 AND Device B has IP on physical interface):
  ERROR: Multiple L2 segments trunked to L3 port
  Action: Apply correction procedure
ELIF (M > 1 AND Device A has IP on physical interface):
  ERROR: Multiple L2 segments trunked to L3 port
  Action: Apply correction procedure
ELIF (N == 1 AND Device B has IP on physical interface):
  VALID: Single L2 segment trunk to L3 port (exception allowed)
ELIF (M == 1 AND Device A has IP on physical interface):
  VALID: Single L2 segment trunk to L3 port (exception allowed)
ELSE:
  VALID: Configuration is correct

Step 5: Document validation result

L2/L3 TRUNK PORT TYPE COMPATIBILITY CHECKLIST:
For each interface pair:
- L2 segment count checked on both interfaces
- L3 configuration type identified (physical port vs SVI)
- Multiple L2 segments to L3 physical port error detected
- Single L2 segment to L3 physical port exception validated
- Correction applied if needed
- Post-correction verification completed

ERROR DETECTION SUMMARY:
INVALID Configurations:
1. L2 Port (2+ VLANs) <-> L3 Physical Port
2. L2 Port (2+ VLANs) <-> L3 Physical Port with IP

VALID Configurations:
1. L2 Port (2+ VLANs) <-> L2 Port (2+ VLANs)
2. L2 Port (1 VLAN) <-> L3 Physical Port (exception)
3. L3 Physical Port <-> L3 Physical Port
4. L2 Port (2+ VLANs) <-> L2 Port (matching VLANs) + SVIs

CORRECTION APPROACH:
Convert L3 Physical Port to L2 Switchport + SVI:
1. Delete IP from physical interface
2. Add L2 segment to physical interface (selected VLAN)
3. Create SVI (Virtual Port)
4. Optionally assign IP to SVI

VLAN SELECTION FOR CORRECTION:
Priority: Default VLAN > Management VLAN > Lowest VLAN ID > First in list

================================================================================
SUBSECTION 12.9: INTEGRATION WITH OTHER RULES
================================================================================

RULE 12 INTEGRATION WITH RULE 10 (PORT-CHANNEL VLAN SYMMETRY):
When correcting L2/L3 trunk error on Port-channel:
- Apply correction to physical interfaces first
- Port-channel VLAN symmetry must still be maintained
- Both Port-channel ends must have matching L2 configuration after correction

RULE 12 INTEGRATION WITH RULE 8 (CASCADE DELETION):
When deleting interface with L2/L3 trunk error:
- Use delete l1_link for cascade deletion
- All L2/L3 configurations automatically removed
- No separate correction needed (entire configuration deleted)

RULE 12 INTEGRATION WITH RULE 11 (IP ADDRESSING):
When assigning IP to corrected SVI:
- Follow IP addressing rules (Option 3 recommended)
- Validate octets <= 255
- Use gateway .1 convention
- Match VLAN ID to IP subnet using standard mapping

VERIFICATION INTEGRATION:
Phase 3 verification (Layer 2):
- Check for L2/L3 trunk port type mismatch (Rule 12)
- Verify Port-channel VLAN symmetry (Rule 10)

Phase 4 verification (Layer 3):
- Check L3 broadcast domains for invalid patterns (Rule 12)
- Validate IP address format (Rule 11)

FINAL VERIFICATION (Phase 6):
- No multiple L2 segments trunked to L3 physical port
- Single L2 segment trunk to L3 port documented as exception
- All corrected configurations verified with show commands

================================================================================
SUBSECTION 12.10: SUMMARY - RULE 12 KEY TAKEAWAYS
================================================================================

CORE PRINCIPLE:
Multiple Layer 2 segments (VLANs) on trunk CANNOT connect directly to Layer 3
physical routed port. This creates invalid configuration in Network Sketcher.

EXCEPTION:
Single Layer 2 segment on trunk CAN connect to Layer 3 physical routed port.
This is valid point-to-point configuration.

CORRECTION METHOD:
Convert L3 physical port to L2 switchport + SVI:
1. Remove IP from physical interface (delete ip_address)
2. Add L2 segment to physical interface (add l2_segment)
3. Create SVI (add virtual_port)
4. Assign IP to SVI if needed (add ip_address)

VLAN SELECTION:
Priority: Default VLAN > Management VLAN (10) > Lowest VLAN ID > First in list

ERROR DETECTION:
Check show l3_broadcast_domain for:
- Multiple SVIs from one device + Physical L3 port from peer in same domain
- Pattern indicates multiple L2 segments converging on single L3 physical port

VALIDATION:
For each interface pair:
1. Count L2 segments on both sides
2. Identify L3 configuration type (physical port vs SVI)
3. Apply validation rules:
   - Multiple L2 segments to L3 physical port -> ERROR
   - Single L2 segment to L3 physical port -> VALID (exception)
   - L2 port to L2 port -> VALID
   - L3 port to L3 port -> VALID

INTEGRATION:
- Combine with Port-channel VLAN symmetry (Rule 10)
- Use cascade deletion for removal (Rule 8)
- Follow IP addressing rules for SVI (Rule 11)
- Always verify after correction with show commands

REMEMBER:
"Multiple VLANs to L3 physical port = ERROR. Convert to L2 port + SVI."
"Single VLAN to L3 physical port = VALID exception."

================================================================================
END OF CRITICAL NETWORK SKETCHER ARCHITECTURE CONSTRAINTS
================================================================================